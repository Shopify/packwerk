# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `constant_resolver` gem.
# Please instead update this file by running `bin/tapioca gem constant_resolver`.

# Get information about (partially qualified) constants without loading the application code.
# We infer the fully qualified name and the filepath.
#
# The implementation makes a few assumptions about the code base:
# - `Something::SomeOtherThing` is defined in a path of either `something/some_other_thing.rb` or `something.rb`,
#   relative to the load path. Constants that have their own file do not have all-uppercase names like MAGIC_NUMBER or
#   all-uppercase parts like SomeID. Rails' `zeitwerk` autoloader makes the same assumption.
# - It is OK to not always infer the exact file defining the constant. For example, when a constant is inherited, we
#   have no way of inferring the file it is defined in. You could argue though that inheritance means that another
#   constant with the same name exists in the inheriting class, and this view is sufficient for all our use cases.
#
# source://constant_resolver//lib/constant_resolver/version.rb#3
class ConstantResolver
  # @example usage in a Rails app
  #   config = Rails.application.config
  #   load_paths = (config.eager_load_paths + config.autoload_paths + config.autoload_once_paths)
  #   .map { |p| Pathname.new(p).relative_path_from(Rails.root).to_s }
  #   ConstantResolver.new(
  #   root_path: Rails.root.to_s,
  #   load_paths: load_paths
  #   )
  # @param root_path [String] The root path of the application to analyze
  # @param load_paths [Array<String>] The autoload paths of the application.
  # @param inflector [Object] Any object that implements a `camelize` function.
  # @return [ConstantResolver] a new instance of ConstantResolver
  #
  # source://constant_resolver//lib/constant_resolver.rb#42
  def initialize(root_path:, load_paths:, inflector: T.unsafe(nil)); end

  # @api private
  #
  # source://constant_resolver//lib/constant_resolver.rb#113
  def config; end

  # Maps constant names to file paths.
  #
  # @return [Hash<String, String>]
  #
  # source://constant_resolver//lib/constant_resolver.rb#73
  def file_map; end

  # Resolve a constant via its name.
  # If the name is partially qualified, we need the current namespace path to correctly infer its full name
  #
  # @param const_name [String] The constant's name, fully or partially qualified.
  # @param current_namespace_path [Array<String>] (optional) The namespace of the context in which the constant is
  #   used, e.g. ["Apps", "Models"] for `Apps::Models`. Defaults to [] which means top level.
  # @return [ConstantResolver::ConstantContext]
  #
  # source://constant_resolver//lib/constant_resolver.rb#58
  def resolve(const_name, current_namespace_path: T.unsafe(nil)); end

  private

  # source://constant_resolver//lib/constant_resolver.rb#131
  def ambiguous_constant_message(const_name, paths); end

  # source://constant_resolver//lib/constant_resolver.rb#122
  def coerce_load_paths(load_paths); end

  # source://constant_resolver//lib/constant_resolver.rb#138
  def glob_path(path); end

  # source://constant_resolver//lib/constant_resolver.rb#142
  def resolve_constant(const_name, current_namespace_path, original_name: T.unsafe(nil)); end

  # source://constant_resolver//lib/constant_resolver.rb#155
  def resolve_traversing_namespace_path(const_name, current_namespace_path); end
end

# source://constant_resolver//lib/constant_resolver.rb#17
class ConstantResolver::ConstantContext < ::Struct; end

# source://constant_resolver//lib/constant_resolver.rb#19
class ConstantResolver::DefaultInflector
  # source://constant_resolver//lib/constant_resolver.rb#20
  def camelize(string); end
end

# source://constant_resolver//lib/constant_resolver.rb#16
class ConstantResolver::Error < ::StandardError; end

# source://constant_resolver//lib/constant_resolver/version.rb#4
ConstantResolver::VERSION = T.let(T.unsafe(nil), String)
