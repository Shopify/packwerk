# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `parser` gem.
# Please instead update this file by running `bin/tapioca gem parser`.

# @api public
#
# source://parser-3.1.2.1/lib/parser.rb:19
module Parser
  class << self
    private

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/current.rb:5
    def warn_syntax_deviation(feature, version); end
  end
end

# @api public
#
# source://parser-3.1.2.1/lib/parser.rb:24
module Parser::AST; end

# {Parser::AST::Node} contains information about a single AST node and its
# child nodes. It extends the basic [AST::Node](http://rdoc.info/gems/ast/AST/Node)
# class provided by gem [ast](http://rdoc.info/gems/ast).
#
# @api public
#
# source://parser-3.1.2.1/lib/parser/ast/node.rb:17
class Parser::AST::Node < ::AST::Node
  # Assigns various properties to this AST node. Currently only the
  # location can be set.
  #
  # @api public
  # @option properties
  # @param properties [Hash]
  #
  # source://parser-3.1.2.1/lib/parser/ast/node.rb:30
  def assign_properties(properties); end

  # Source map for this Node.
  #
  # @api public
  # @return [Parser::Source::Map]
  #
  # source://parser-3.1.2.1/lib/parser/ast/node.rb:18
  def loc; end

  # Source map for this Node.
  #
  # @api public
  # @return [Parser::Source::Map]
  #
  # source://parser-3.1.2.1/lib/parser/ast/node.rb:18
  def location; end
end

# @api public
#
# source://parser-3.1.2.1/lib/parser/ast/processor.rb:9
class Parser::AST::Processor < ::AST::Processor
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_alias(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_and(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_and_asgn(node); end

  # @api public
  # @private
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:116
  def on_arg(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_arg_expr(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_args(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:103
  def on_argument(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_array(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_array_pattern(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_array_pattern_with_tail(node); end

  # @api public
  # @private
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:32
  def on_back_ref(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_begin(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_block(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_block_pass(node); end

  # @api public
  # @private
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:116
  def on_blockarg(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_blockarg_expr(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_break(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_case(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_case_match(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:87
  def on_casgn(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_class(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:79
  def on_const(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_const_pattern(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:176
  def on_csend(node); end

  # @api public
  # @private
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:32
  def on_cvar(node); end

  # @api public
  # @private
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:56
  def on_cvasgn(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:155
  def on_def(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_defined?(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:164
  def on_defs(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_dstr(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_dsym(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_eflipflop(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:283
  def on_empty_else(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_ensure(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_erange(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_find_pattern(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_for(node); end

  # @api public
  # @private
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:116
  def on_forward_arg(node); end

  # @api public
  # @private
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:32
  def on_gvar(node); end

  # @api public
  # @private
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:56
  def on_gvasgn(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_hash(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_hash_pattern(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_if(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_if_guard(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_iflipflop(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_in_match(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_in_pattern(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_index(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_indexasgn(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_irange(node); end

  # @api public
  # @private
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:32
  def on_ivar(node); end

  # @api public
  # @private
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:56
  def on_ivasgn(node); end

  # @api public
  # @private
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:116
  def on_kwarg(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_kwargs(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_kwbegin(node); end

  # @api public
  # @private
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:116
  def on_kwoptarg(node); end

  # @api public
  # @private
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:116
  def on_kwrestarg(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_kwsplat(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_lambda(node); end

  # @api public
  # @private
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:32
  def on_lvar(node); end

  # @api public
  # @private
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:56
  def on_lvasgn(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_masgn(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_match_alt(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_match_as(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_match_current_line(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_match_pattern(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_match_pattern_p(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_match_rest(node); end

  # @api public
  # @private
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:32
  def on_match_var(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_match_with_lvasgn(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_mlhs(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_module(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_next(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_not(node); end

  # @api public
  # @private
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:32
  def on_nth_ref(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:193
  def on_numblock(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:68
  def on_op_asgn(node); end

  # @api public
  # @private
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:116
  def on_optarg(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_or(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_or_asgn(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_pair(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_pin(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_postexe(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_preexe(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:130
  def on_procarg0(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_redo(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_regexp(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_resbody(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_rescue(node); end

  # @api public
  # @private
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:116
  def on_restarg(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_restarg_expr(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_retry(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_return(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_sclass(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:176
  def on_send(node); end

  # @api public
  # @private
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:116
  def on_shadowarg(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_splat(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_super(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_undef(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_unless_guard(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_until(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_until_post(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:27
  def on_var(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:43
  def on_vasgn(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_when(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_while(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_while_post(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_xstr(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def on_yield(node); end

  # @api public
  # @private
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:276
  def process_argument_node(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:10
  def process_regular_node(node); end

  # @api public
  # @private
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:268
  def process_var_asgn_node(node); end

  # @api public
  # @private
  #
  # source://parser-3.1.2.1/lib/parser/ast/processor.rb:260
  def process_variable_node(node); end
end

# Base class for version-specific parsers.
#
# @api public
#
# source://parser-3.1.2.1/lib/parser/base.rb:29
class Parser::Base < ::Racc::Parser
  # @api public
  # @param builder [Parser::Builders::Default] The AST builder to use.
  # @return [Base] a new instance of Base
  #
  # source://parser-3.1.2.1/lib/parser/base.rb:126
  def initialize(builder = T.unsafe(nil)); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/base.rb:114
  def builder; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/base.rb:117
  def context; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/base.rb:119
  def current_arg_stack; end

  # @api public
  # @return [Parser::Diagnostic::Engine]
  #
  # source://parser-3.1.2.1/lib/parser/base.rb:113
  def diagnostics; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/base.rb:112
  def lexer; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/base.rb:118
  def max_numparam_stack; end

  # Parses a source buffer and returns the AST, or `nil` in case of a non fatal error.
  #
  # @api public
  # @param source_buffer [Parser::Source::Buffer] The source buffer to parse.
  # @return [Parser::AST::Node, nil]
  #
  # source://parser-3.1.2.1/lib/parser/base.rb:186
  def parse(source_buffer); end

  # Parses a source buffer and returns the AST and the source code comments.
  #
  # @api public
  # @return [Array]
  # @see #parse
  # @see Parser::Source::Comment#associate
  #
  # source://parser-3.1.2.1/lib/parser/base.rb:204
  def parse_with_comments(source_buffer); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/base.rb:121
  def pattern_hash_keys; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/base.rb:120
  def pattern_variables; end

  # Resets the state of the parser.
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/base.rb:167
  def reset; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/base.rb:116
  def source_buffer; end

  # @api public
  # @return [Parser::StaticEnvironment]
  #
  # source://parser-3.1.2.1/lib/parser/base.rb:115
  def static_env; end

  # Parses a source buffer and returns the AST, the source code comments,
  # and the tokens emitted by the lexer. In case of a fatal error, a {SyntaxError}
  # is raised, unless `recover` is true. In case of an error
  # (non-fatal or recovered), `nil` is returned instead of the AST, and
  # comments as well as tokens are only returned up to the location of
  # the error.
  #
  # Currently, token stream format returned by #tokenize is not documented,
  # but is considered part of a public API and only changed according
  # to Semantic Versioning.
  #
  # However, note that the exact token composition of various constructs
  # might vary. For example, a string `"foo"` is represented equally well
  # by `:tSTRING_BEG " :tSTRING_CONTENT foo :tSTRING_END "` and
  # `:tSTRING "foo"`; such details must not be relied upon.
  #
  # @api public
  # @param source_buffer [Parser::Source::Buffer]
  # @param recover [Boolean] If true, recover from syntax errors. False by default.
  # @return [Array]
  #
  # source://parser-3.1.2.1/lib/parser/base.rb:233
  def tokenize(source_buffer, recover = T.unsafe(nil)); end

  private

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/base.rb:257
  def check_kwarg_name(name_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/base.rb:266
  def diagnostic(level, reason, arguments, location_t, highlights_ts = T.unsafe(nil)); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/base.rb:251
  def next_token; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/base.rb:282
  def on_error(error_token_id, error_value, value_stack); end

  class << self
    # @api public
    # @return [Parser::Base] parser with the default options set.
    #
    # source://parser-3.1.2.1/lib/parser/base.rb:84
    def default_parser; end

    # Parses a string of Ruby code and returns the AST. If the source
    # cannot be parsed, {SyntaxError} is raised and a diagnostic is
    # printed to `stderr`.
    #
    # @api public
    # @example
    #   Parser::Base.parse('puts "hello"')
    # @param string [String] The block of code to parse.
    # @param file [String] The name of the file the code originated from.
    # @param line [Numeric] The initial line number.
    # @return [Parser::AST::Node]
    #
    # source://parser-3.1.2.1/lib/parser/base.rb:30
    def parse(string, file = T.unsafe(nil), line = T.unsafe(nil)); end

    # Parses Ruby source code by reading it from a file. If the source
    # cannot be parsed, {SyntaxError} is raised and a diagnostic is
    # printed to `stderr`.
    #
    # @api public
    # @param filename [String] Path to the file to parse.
    # @return [Parser::AST::Node]
    # @see #parse
    #
    # source://parser-3.1.2.1/lib/parser/base.rb:64
    def parse_file(filename); end

    # Parses Ruby source code by reading it from a file and returns the AST and
    # comments. If the source cannot be parsed, {SyntaxError} is raised and a
    # diagnostic is printed to `stderr`.
    #
    # @api public
    # @param filename [String] Path to the file to parse.
    # @return [Array]
    # @see #parse
    #
    # source://parser-3.1.2.1/lib/parser/base.rb:77
    def parse_file_with_comments(filename); end

    # Parses a string of Ruby code and returns the AST and comments. If the
    # source cannot be parsed, {SyntaxError} is raised and a diagnostic is
    # printed to `stderr`.
    #
    # @api public
    # @example
    #   Parser::Base.parse_with_comments('puts "hello"')
    # @param string [String] The block of code to parse.
    # @param file [String] The name of the file the code originated from.
    # @param line [Numeric] The initial line number.
    # @return [Array]
    #
    # source://parser-3.1.2.1/lib/parser/base.rb:49
    def parse_with_comments(string, file = T.unsafe(nil), line = T.unsafe(nil)); end

    private

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/base.rb:97
    def setup_source_buffer(file, line, string, encoding); end
  end
end

# @api public
#
# source://parser-3.1.2.1/lib/parser.rb:72
module Parser::Builders; end

# Default AST builder. Uses {AST::Node}s.
#
# @api public
#
# source://parser-3.1.2.1/lib/parser/builders/default.rb:8
class Parser::Builders::Default
  # Initializes attributes:
  #
  #   * `emit_file_line_as_literals`: `true`
  #
  # @api public
  # @return [Default] a new instance of Default
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:243
  def initialize; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:696
  def __ENCODING__(__ENCODING__t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:348
  def __FILE__(__FILE__t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:312
  def __LINE__(__LINE__t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:622
  def accessible(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:871
  def alias(alias_t, to, from); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:910
  def arg(name_t); end

  # Ruby 1.8 block arguments
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1000
  def arg_expr(expr); end

  # Formal arguments
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:880
  def args(begin_t, args, end_t, check_args = T.unsafe(nil)); end

  # Arrays
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:440
  def array(begin_t, elements, end_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1575
  def array_pattern(lbrack_t, elements, rbrack_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:760
  def assign(lhs, eql_t, rhs); end

  # Assignment
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:705
  def assignable(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:540
  def associate(begin_t, pairs, end_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1156
  def attr_asgn(receiver, dot_t, selector_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:612
  def back_ref(token); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1420
  def begin(begin_t, body, end_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1362
  def begin_body(compound_stmt, rescue_bodies = T.unsafe(nil), else_t = T.unsafe(nil), else_ = T.unsafe(nil), ensure_t = T.unsafe(nil), ensure_ = T.unsafe(nil)); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1438
  def begin_keyword(begin_t, body, end_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1190
  def binary_op(receiver, operator_t, arg); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1107
  def block(method_call, begin_t, args, body, end_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1142
  def block_pass(amper_t, arg); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:975
  def blockarg(amper_t, name_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1020
  def blockarg_expr(amper_t, expr); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1098
  def call_lambda(lambda_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1081
  def call_method(receiver, dot_t, selector_t, lparen_t = T.unsafe(nil), args = T.unsafe(nil), rparen_t = T.unsafe(nil)); end

  # Method calls
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1061
  def call_type_for_dot(dot_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1295
  def case(case_t, expr, when_bodies, else_t, else_body, end_t); end

  # PATTERN MATCHING
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1458
  def case_match(case_t, expr, in_bodies, else_t, else_body, end_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:343
  def character(char_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:284
  def complex(complex_t); end

  # Expression grouping
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1408
  def compstmt(statements); end

  # Conditionals
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1271
  def condition(cond_t, cond, then_t, if_true, else_t, if_false, end_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1277
  def condition_mod(if_true, if_false, cond_t, cond); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:679
  def const(name_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:691
  def const_fetch(scope, t_colon2, name_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:684
  def const_global(t_colon3, name_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:756
  def const_op_assignable(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1605
  def const_pattern(const, ldelim_t, pattern, rdelim_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:607
  def cvar(token); end

  # Indented (interpolated, noninterpolated, executable) strings
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:388
  def dedent_string(node, dedent_level); end

  # Class and module definition
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:807
  def def_class(class_t, name, lt_t, superclass, body, end_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:838
  def def_endless_method(def_t, name_t, args, assignment_t, body); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:856
  def def_endless_singleton(def_t, definee, dot_t, name_t, args, assignment_t, body); end

  # Method (un)definition
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:830
  def def_method(def_t, name_t, args, body, end_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:820
  def def_module(module_t, name, body, end_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:814
  def def_sclass(class_t, lshft_t, expr, body, end_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:846
  def def_singleton(def_t, definee, dot_t, name_t, args, body, end_t); end

  # If set to true (the default), `__FILE__` and `__LINE__` are transformed to
  # literal nodes. For example, `s(:str, "lib/foo.rb")` and `s(:int, 10)`.
  #
  # If set to false, `__FILE__` and `__LINE__` are emitted as-is,
  # i.e. as `s(:__FILE__)` and `s(:__LINE__)` nodes.
  #
  # Source maps are identical in both cases.
  #
  # @api public
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:237
  def emit_file_line_as_literals; end

  # If set to true (the default), `__FILE__` and `__LINE__` are transformed to
  # literal nodes. For example, `s(:str, "lib/foo.rb")` and `s(:int, 10)`.
  #
  # If set to false, `__FILE__` and `__LINE__` are emitted as-is,
  # i.e. as `s(:__FILE__)` and `s(:__LINE__)` nodes.
  #
  # Source maps are identical in both cases.
  #
  # @api public
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:237
  def emit_file_line_as_literals=(_arg0); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:265
  def false(false_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1596
  def find_pattern(lbrack_t, elements, rbrack_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:276
  def float(float_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1316
  def for(for_t, iterator, in_t, iteratee, do_t, body, end_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:906
  def forward_arg(dots_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:896
  def forward_only_args(begin_t, dots_t, end_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1077
  def forwarded_args(dots_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:602
  def gvar(token); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1569
  def hash_pattern(lbrace_t, kwargs, rbrace_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:592
  def ident(token); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1485
  def if_guard(if_t, if_body); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1464
  def in_match(lhs, in_t, rhs); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1479
  def in_pattern(in_t, pattern, guard, then_t, body); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1165
  def index(receiver, lbrack_t, indexes, rbrack_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1179
  def index_asgn(receiver, lbrack_t, indexes, rbrack_t); end

  # Numerics
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:272
  def integer(integer_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:597
  def ivar(token); end

  # Keywords
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1324
  def keyword_cmd(type, keyword_t, lparen_t = T.unsafe(nil), args = T.unsafe(nil), rparen_t = T.unsafe(nil)); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:937
  def kwarg(name_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:963
  def kwnilarg(dstar_t, nil_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:944
  def kwoptarg(name_t, value); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:951
  def kwrestarg(dstar_t, name_t = T.unsafe(nil)); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:535
  def kwsplat(dstar_t, arg); end

  # Logical operations: and, or
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1264
  def logical_op(type, lhs, op_t, rhs); end

  # Loops
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1302
  def loop(type, keyword_t, cond, do_t, body, end_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1307
  def loop_mod(type, body, keyword_t, cond); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1619
  def match_alt(left, pipe_t, right); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1626
  def match_as(value, assoc_t, as); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1505
  def match_hash_var(name_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1519
  def match_hash_var_from_str(begin_t, strings, end_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1657
  def match_label(label_type, label); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1633
  def match_nil_pattern(dstar_t, nil_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1212
  def match_op(receiver, match_t, arg); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1638
  def match_pair(label_type, label, value); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1469
  def match_pattern(lhs, match_t, rhs); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1474
  def match_pattern_p(lhs, match_t, rhs); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1558
  def match_rest(star_t, name_t = T.unsafe(nil)); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1493
  def match_var(name_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1601
  def match_with_trailing_comma(match, comma_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:798
  def multi_assign(lhs, eql_t, rhs); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:793
  def multi_lhs(begin_t, items, end_t); end

  # Singletons
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:255
  def nil(nil_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1240
  def not_op(not_t, begin_t = T.unsafe(nil), receiver = T.unsafe(nil), end_t = T.unsafe(nil)); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:617
  def nth_ref(token); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:892
  def numargs(max_numparam); end

  # MacRuby Objective-C arguments
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1031
  def objc_kwarg(kwname_t, assoc_t, name_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1045
  def objc_restarg(star_t, name = T.unsafe(nil)); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1147
  def objc_varargs(pair, rest_of_varargs); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:767
  def op_assign(lhs, op_t, rhs); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:917
  def optarg(name_t, eql_t, value); end

  # Hashes
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:488
  def pair(key, assoc_t, value); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:505
  def pair_keyword(key_t, value); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:521
  def pair_label(key_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:493
  def pair_list_18(list); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:513
  def pair_quoted(begin_t, parts, end_t, value); end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:225
  def parser; end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:225
  def parser=(_arg0); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1614
  def pin(pin_t, var); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1347
  def postexe(postexe_t, lbrace_t, compstmt, rbrace_t); end

  # BEGIN, END
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1342
  def preexe(preexe_t, lbrace_t, compstmt, rbrace_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:985
  def procarg0(arg); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:578
  def range_exclusive(lhs, dot3_t, rhs); end

  # Ranges
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:573
  def range_inclusive(lhs, dot2_t, rhs); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:280
  def rational(rational_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:426
  def regexp_compose(begin_t, parts, end_t, options); end

  # Regular expressions
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:417
  def regexp_options(regopt_t); end

  # Exception handling
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1354
  def rescue_body(rescue_t, exc_list, assoc_t, exc_var, then_t, compound_stmt); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:926
  def restarg(star_t, name_t = T.unsafe(nil)); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1009
  def restarg_expr(star_t, expr = T.unsafe(nil)); end

  # Access
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:587
  def self(token); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:968
  def shadowarg(name_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:445
  def splat(star_t, arg = T.unsafe(nil)); end

  # Strings
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:319
  def string(string_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:329
  def string_compose(begin_t, parts, end_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:324
  def string_internal(string_t); end

  # Symbols
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:355
  def symbol(symbol_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:365
  def symbol_compose(begin_t, parts, end_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:360
  def symbol_internal(symbol_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:469
  def symbols_compose(begin_t, parts, end_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1282
  def ternary(cond, question_t, if_true, colon_t, if_false); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:260
  def true(true_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:294
  def unary_num(unary_t, numeric); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1228
  def unary_op(op_t, receiver); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:866
  def undef_method(undef_t, names); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1489
  def unless_guard(unless_t, unless_body); end

  # Case matching
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1289
  def when(when_t, patterns, then_t, body); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:455
  def word(parts); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:464
  def words_compose(begin_t, parts, end_t); end

  # Executable strings
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:381
  def xstring_compose(begin_t, parts, end_t); end

  private

  # @api public
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1796
  def arg_name_collides?(this_name, that_name); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1992
  def arg_prefix_map(op_t, name_t = T.unsafe(nil)); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1966
  def binary_op_map(left_e, op_t, right_e); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:2094
  def block_map(receiver_l, begin_t, end_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1771
  def check_assignment_to_numparam(name, loc); end

  # VERIFICATION
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1673
  def check_condition(cond); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1742
  def check_duplicate_arg(this_arg, map = T.unsafe(nil)); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1717
  def check_duplicate_args(args, map = T.unsafe(nil)); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1829
  def check_duplicate_pattern_key(name, loc); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1819
  def check_duplicate_pattern_variable(name, loc); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1811
  def check_lvar_name(name, loc); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1786
  def check_reserved_for_numparam(name, loc); end

  # @api public
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:2251
  def collapse_string_parts?(parts); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1917
  def collection_map(begin_t, parts, end_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:2121
  def condition_map(keyword_t, cond_e, begin_t, body_e, else_t, else_e, end_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1952
  def constant_map(scope, colon2_t, name_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:2025
  def definition_map(keyword_t, operator_t, name_t, end_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1858
  def delimited_string_map(string_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:2273
  def diagnostic(type, reason, arguments, location, highlights = T.unsafe(nil)); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:2165
  def eh_keyword_map(compstmt_e, keyword_t, body_es, else_t, else_e); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:2031
  def endless_definition_map(keyword_t, operator_t, name_t, assignment_t, body_e); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1913
  def expr_map(loc); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:2146
  def for_map(keyword_t, in_t, begin_t, end_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:2193
  def guard_map(keyword_t, guard_body_e); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:2083
  def index_map(receiver_e, lbrack_t, rbrack_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1849
  def join_exprs(left_expr, right_expr); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:2099
  def keyword_map(keyword_t, begin_t, args, end_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:2116
  def keyword_mod_map(pre_e, keyword_t, post_e); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:2002
  def kwarg_map(name_t, value_e = T.unsafe(nil)); end

  # @api public
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:2304
  def kwargs?(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:2268
  def loc(token); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:2015
  def module_definition_map(keyword_t, name_e, operator_t, end_t); end

  # SOURCE MAPS
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1841
  def n(type, children, source_map); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1845
  def n0(type, source_map); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:288
  def numeric(kind, token); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1883
  def pair_keyword_map(key_t, value_e); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1898
  def pair_quoted_map(begin_t, end_t, value_e); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1869
  def prefix_string_map(symbol); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1980
  def range_map(start_e, op_t, end_e); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1947
  def regexp_map(begin_t, end_t, options_e); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:2152
  def rescue_body_map(keyword_t, exc_list_e, assoc_t, exc_var_e, then_t, compstmt_e); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:2294
  def rewrite_hash_args_to_kwargs(args); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:2065
  def send_binary_op_map(lhs_e, selector_t, rhs_e); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:2088
  def send_index_map(receiver_e, lbrack_t, rbrack_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:2039
  def send_map(receiver_e, dot_t, selector_t, begin_t = T.unsafe(nil), args = T.unsafe(nil), end_t = T.unsafe(nil)); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:2071
  def send_unary_op_map(selector_t, arg_e); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:2224
  def static_regexp(parts, options); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:2244
  def static_regexp_node(node); end

  # Extract a static string from e.g. a regular expression,
  # honoring the fact that MRI expands interpolations like #{""}
  # at parse time.
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:2207
  def static_string(nodes); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1933
  def string_map(begin_t, parts, end_t); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:2260
  def string_value(token); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:2141
  def ternary_map(begin_e, question_t, mid_e, colon_t, end_e); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1854
  def token_map(token); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1970
  def unary_op_map(op_t, arg_e = T.unsafe(nil)); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1878
  def unquoted_map(token); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:2282
  def validate_definee(definee); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1756
  def validate_no_forward_arg_after_restarg(args); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:2256
  def value(token); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:2059
  def var_send_map(variable_e); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/builders/default.rb:1962
  def variable_map(name_t); end

  class << self
    # AST compatibility attribute; causes a single non-mlhs
    # block argument to be wrapped in s(:procarg0).
    #
    # If set to false (the default), block arguments `|a|` are emitted as
    # `s(:args, s(:procarg0, :a))`
    #
    # If set to true, block arguments `|a|` are emitted as
    # `s(:args, s(:procarg0, s(:arg, :a))`
    #
    # @api public
    # @return [Boolean]
    #
    # source://parser-3.1.2.1/lib/parser/builders/default.rb:97
    def emit_arg_inside_procarg0; end

    # AST compatibility attribute; causes a single non-mlhs
    # block argument to be wrapped in s(:procarg0).
    #
    # If set to false (the default), block arguments `|a|` are emitted as
    # `s(:args, s(:procarg0, :a))`
    #
    # If set to true, block arguments `|a|` are emitted as
    # `s(:args, s(:procarg0, s(:arg, :a))`
    #
    # @api public
    # @return [Boolean]
    #
    # source://parser-3.1.2.1/lib/parser/builders/default.rb:97
    def emit_arg_inside_procarg0=(_arg0); end

    # AST compatibility attribute; locations of `__ENCODING__` are not the same
    # as locations of `Encoding::UTF_8` causing problems during rewriting,
    # all new code should set this attribute to true.
    #
    # If set to false (the default), `__ENCODING__` is emitted as
    # ` s(:const, s(:const, nil, :Encoding), :UTF_8)`.
    #
    # If set to true, `__ENCODING__` is emitted as
    # `s(:__ENCODING__)`.
    #
    # @api public
    # @return [Boolean]
    #
    # source://parser-3.1.2.1/lib/parser/builders/default.rb:58
    def emit_encoding; end

    # AST compatibility attribute; locations of `__ENCODING__` are not the same
    # as locations of `Encoding::UTF_8` causing problems during rewriting,
    # all new code should set this attribute to true.
    #
    # If set to false (the default), `__ENCODING__` is emitted as
    # ` s(:const, s(:const, nil, :Encoding), :UTF_8)`.
    #
    # If set to true, `__ENCODING__` is emitted as
    # `s(:__ENCODING__)`.
    #
    # @api public
    # @return [Boolean]
    #
    # source://parser-3.1.2.1/lib/parser/builders/default.rb:58
    def emit_encoding=(_arg0); end

    # AST compatibility attribute; arguments forwarding initially
    # didn't have support for leading arguments
    # (i.e. `def m(a, ...); end` was a syntax error). However, Ruby 3.0
    # added support for any number of arguments in front of the `...`.
    #
    # If set to false (the default):
    #   1. `def m(...) end` is emitted as
    #      s(:def, :m, s(:forward_args), nil)
    #   2. `def m(a, b, ...) end` is emitted as
    #      s(:def, :m,
    #        s(:args, s(:arg, :a), s(:arg, :b), s(:forward_arg)))
    #
    # If set to true it uses a single format:
    #   1. `def m(...) end` is emitted as
    #      s(:def, :m, s(:args, s(:forward_arg)))
    #   2. `def m(a, b, ...) end` is emitted as
    #      s(:def, :m, s(:args, s(:arg, :a), s(:arg, :b), s(:forward_arg)))
    #
    # It does't matter that much on 2.7 (because there can't be any leading arguments),
    # but on 3.0 it should be better enabled to use a single AST format.
    #
    # @api public
    # @return [Boolean]
    #
    # source://parser-3.1.2.1/lib/parser/builders/default.rb:126
    def emit_forward_arg; end

    # AST compatibility attribute; arguments forwarding initially
    # didn't have support for leading arguments
    # (i.e. `def m(a, ...); end` was a syntax error). However, Ruby 3.0
    # added support for any number of arguments in front of the `...`.
    #
    # If set to false (the default):
    #   1. `def m(...) end` is emitted as
    #      s(:def, :m, s(:forward_args), nil)
    #   2. `def m(a, b, ...) end` is emitted as
    #      s(:def, :m,
    #        s(:args, s(:arg, :a), s(:arg, :b), s(:forward_arg)))
    #
    # If set to true it uses a single format:
    #   1. `def m(...) end` is emitted as
    #      s(:def, :m, s(:args, s(:forward_arg)))
    #   2. `def m(a, b, ...) end` is emitted as
    #      s(:def, :m, s(:args, s(:arg, :a), s(:arg, :b), s(:forward_arg)))
    #
    # It does't matter that much on 2.7 (because there can't be any leading arguments),
    # but on 3.0 it should be better enabled to use a single AST format.
    #
    # @api public
    # @return [Boolean]
    #
    # source://parser-3.1.2.1/lib/parser/builders/default.rb:126
    def emit_forward_arg=(_arg0); end

    # AST compatibility attribute; indexed assignment, `x[] = 1`, is not
    # semantically equivalent to calling the method directly, `x.[]=(1)`.
    # Specifically, in the former case, the expression's value is always 1,
    # and in the latter case, the expression's value is the return value
    # of the `[]=` method.
    #
    # If set to false (the default), `self[1]` is emitted as
    # `s(:send, s(:self), :[], s(:int, 1))`, and `self[1] = 2` is
    # emitted as `s(:send, s(:self), :[]=, s(:int, 1), s(:int, 2))`.
    #
    # If set to true, `self[1]` is emitted as
    # `s(:index, s(:self), s(:int, 1))`, and `self[1] = 2` is
    # emitted as `s(:indexasgn, s(:self), s(:int, 1), s(:int, 2))`.
    #
    # @api public
    # @return [Boolean]
    #
    # source://parser-3.1.2.1/lib/parser/builders/default.rb:80
    def emit_index; end

    # AST compatibility attribute; indexed assignment, `x[] = 1`, is not
    # semantically equivalent to calling the method directly, `x.[]=(1)`.
    # Specifically, in the former case, the expression's value is always 1,
    # and in the latter case, the expression's value is the return value
    # of the `[]=` method.
    #
    # If set to false (the default), `self[1]` is emitted as
    # `s(:send, s(:self), :[], s(:int, 1))`, and `self[1] = 2` is
    # emitted as `s(:send, s(:self), :[]=, s(:int, 1), s(:int, 2))`.
    #
    # If set to true, `self[1]` is emitted as
    # `s(:index, s(:self), s(:int, 1))`, and `self[1] = 2` is
    # emitted as `s(:indexasgn, s(:self), s(:int, 1), s(:int, 2))`.
    #
    # @api public
    # @return [Boolean]
    #
    # source://parser-3.1.2.1/lib/parser/builders/default.rb:80
    def emit_index=(_arg0); end

    # AST compatibility attribute; Starting from Ruby 2.7 keyword arguments
    # of method calls that are passed explicitly as a hash (i.e. with curly braces)
    # are treated as positional arguments and Ruby 2.7 emits a warning on such method
    # call. Ruby 3.0 given an ArgumentError.
    #
    # If set to false (the default) the last hash argument is emitted as `hash`:
    #
    # ```
    # (send nil :foo
    #   (hash
    #     (pair
    #       (sym :bar)
    #       (int 42))))
    # ```
    #
    # If set to true it is emitted as `kwargs`:
    #
    # ```
    # (send nil :foo
    #   (kwargs
    #     (pair
    #       (sym :bar)
    #       (int 42))))
    # ```
    #
    # Note that `kwargs` node is just a replacement for `hash` argument,
    # so if there's are multiple arguments (or a `kwsplat`) all of them
    # are wrapped into `kwargs` instead of `hash`:
    #
    # ```
    # (send nil :foo
    #   (kwargs
    #     (pair
    #       (sym :a)
    #       (int 42))
    #     (kwsplat
    #       (send nil :b))
    #     (pair
    #       (sym :c)
    #       (int 10))))
    # ```
    #
    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/builders/default.rb:174
    def emit_kwargs; end

    # AST compatibility attribute; Starting from Ruby 2.7 keyword arguments
    # of method calls that are passed explicitly as a hash (i.e. with curly braces)
    # are treated as positional arguments and Ruby 2.7 emits a warning on such method
    # call. Ruby 3.0 given an ArgumentError.
    #
    # If set to false (the default) the last hash argument is emitted as `hash`:
    #
    # ```
    # (send nil :foo
    #   (hash
    #     (pair
    #       (sym :bar)
    #       (int 42))))
    # ```
    #
    # If set to true it is emitted as `kwargs`:
    #
    # ```
    # (send nil :foo
    #   (kwargs
    #     (pair
    #       (sym :bar)
    #       (int 42))))
    # ```
    #
    # Note that `kwargs` node is just a replacement for `hash` argument,
    # so if there's are multiple arguments (or a `kwsplat`) all of them
    # are wrapped into `kwargs` instead of `hash`:
    #
    # ```
    # (send nil :foo
    #   (kwargs
    #     (pair
    #       (sym :a)
    #       (int 42))
    #     (kwsplat
    #       (send nil :b))
    #     (pair
    #       (sym :c)
    #       (int 10))))
    # ```
    #
    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/builders/default.rb:174
    def emit_kwargs=(_arg0); end

    # AST compatibility attribute; since `-> {}` is not semantically
    # equivalent to `lambda {}`, all new code should set this attribute
    # to true.
    #
    # If set to false (the default), `-> {}` is emitted as
    # `s(:block, s(:send, nil, :lambda), s(:args), nil)`.
    #
    # If set to true, `-> {}` is emitted as
    # `s(:block, s(:lambda), s(:args), nil)`.
    #
    # @api public
    # @return [Boolean]
    #
    # source://parser-3.1.2.1/lib/parser/builders/default.rb:22
    def emit_lambda; end

    # AST compatibility attribute; since `-> {}` is not semantically
    # equivalent to `lambda {}`, all new code should set this attribute
    # to true.
    #
    # If set to false (the default), `-> {}` is emitted as
    # `s(:block, s(:send, nil, :lambda), s(:args), nil)`.
    #
    # If set to true, `-> {}` is emitted as
    # `s(:block, s(:lambda), s(:args), nil)`.
    #
    # @api public
    # @return [Boolean]
    #
    # source://parser-3.1.2.1/lib/parser/builders/default.rb:22
    def emit_lambda=(_arg0); end

    # AST compatibility attribute; Starting from 3.0 Ruby returns
    # true/false from single-line pattern matching with `in` keyword.
    #
    # Before 3.0 there was an exception if given value doesn't match pattern.
    #
    # NOTE: This attribute affects only Ruby 2.7 grammar.
    # 3.0 grammar always emits `match_pattern`/`match_pattern_p`
    #
    # If compatibility attribute set to false `foo in bar` is emitted as `in_match`:
    #
    # ```
    # (in-match
    #   (send nil :foo)
    #   (match-var :bar))
    # ```
    #
    # If set to true it's emitted as `match_pattern_p`:
    # ```
    # (match-pattern-p
    #   (send nil :foo)
    #   (match-var :bar))
    # ```
    #
    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/builders/default.rb:203
    def emit_match_pattern; end

    # AST compatibility attribute; Starting from 3.0 Ruby returns
    # true/false from single-line pattern matching with `in` keyword.
    #
    # Before 3.0 there was an exception if given value doesn't match pattern.
    #
    # NOTE: This attribute affects only Ruby 2.7 grammar.
    # 3.0 grammar always emits `match_pattern`/`match_pattern_p`
    #
    # If compatibility attribute set to false `foo in bar` is emitted as `in_match`:
    #
    # ```
    # (in-match
    #   (send nil :foo)
    #   (match-var :bar))
    # ```
    #
    # If set to true it's emitted as `match_pattern_p`:
    # ```
    # (match-pattern-p
    #   (send nil :foo)
    #   (match-var :bar))
    # ```
    #
    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/builders/default.rb:203
    def emit_match_pattern=(_arg0); end

    # AST compatibility attribute; block arguments of `m { |a| }` are
    # not semantically equivalent to block arguments of `m { |a,| }` or `m { |a, b| }`,
    # all new code should set this attribute to true.
    #
    # If set to false (the default), arguments of `m { |a| }` are emitted as
    # `s(:args, s(:arg, :a))`.
    #
    # If set to true, arguments of `m { |a| }` are emitted as
    # `s(:args, s(:procarg0, :a)).
    #
    # @api public
    # @return [Boolean]
    #
    # source://parser-3.1.2.1/lib/parser/builders/default.rb:40
    def emit_procarg0; end

    # AST compatibility attribute; block arguments of `m { |a| }` are
    # not semantically equivalent to block arguments of `m { |a,| }` or `m { |a, b| }`,
    # all new code should set this attribute to true.
    #
    # If set to false (the default), arguments of `m { |a| }` are emitted as
    # `s(:args, s(:arg, :a))`.
    #
    # If set to true, arguments of `m { |a| }` are emitted as
    # `s(:args, s(:procarg0, :a)).
    #
    # @api public
    # @return [Boolean]
    #
    # source://parser-3.1.2.1/lib/parser/builders/default.rb:40
    def emit_procarg0=(_arg0); end

    # @api private
    #
    # source://parser-3.1.2.1/lib/parser/builders/default.rb:211
    def modernize; end
  end
end

# {Parser::ClobberingError} is raised when {Parser::Source::Rewriter}
# detects a clobbering rewrite action. This class inherits {RuntimeError}
# rather than {StandardError} for backward compatibility.
#
# @api public
#
# source://parser-3.1.2.1/lib/parser/clobbering_error.rb:11
class Parser::ClobberingError < ::RuntimeError; end

# Context of parsing that is represented by a stack of scopes.
#
# Supported states:
# + :class - in the class body (class A; end)
# + :module - in the module body (module M; end)
# + :sclass - in the singleton class body (class << obj; end)
# + :def - in the method body (def m; end)
# + :defs - in the singleton method body (def self.m; end)
# + :def_open_args - in the arglist of the method definition
#                    keep in mind that it's set **only** after reducing the first argument,
#                    if you need to handle the first argument check `lex_state == expr_fname`
# + :block - in the block body (tap {})
# + :lambda - in the lambda body (-> {})
#
# @api public
#
# source://parser-3.1.2.1/lib/parser/context.rb:18
class Parser::Context
  # @api public
  # @return [Context] a new instance of Context
  #
  # source://parser-3.1.2.1/lib/parser/context.rb:29
  def initialize; end

  # source://parser-3.1.2.1/lib/parser/context.rb:43
  def in_argdef; end

  # source://parser-3.1.2.1/lib/parser/context.rb:43
  def in_argdef=(_arg0); end

  # source://parser-3.1.2.1/lib/parser/context.rb:43
  def in_block; end

  # source://parser-3.1.2.1/lib/parser/context.rb:43
  def in_block=(_arg0); end

  # source://parser-3.1.2.1/lib/parser/context.rb:43
  def in_class; end

  # source://parser-3.1.2.1/lib/parser/context.rb:43
  def in_class=(_arg0); end

  # source://parser-3.1.2.1/lib/parser/context.rb:43
  def in_def; end

  # source://parser-3.1.2.1/lib/parser/context.rb:43
  def in_def=(_arg0); end

  # source://parser-3.1.2.1/lib/parser/context.rb:43
  def in_defined; end

  # source://parser-3.1.2.1/lib/parser/context.rb:43
  def in_defined=(_arg0); end

  # @api public
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/context.rb:45
  def in_dynamic_block?; end

  # source://parser-3.1.2.1/lib/parser/context.rb:43
  def in_kwarg; end

  # source://parser-3.1.2.1/lib/parser/context.rb:43
  def in_kwarg=(_arg0); end

  # source://parser-3.1.2.1/lib/parser/context.rb:43
  def in_lambda; end

  # source://parser-3.1.2.1/lib/parser/context.rb:43
  def in_lambda=(_arg0); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/context.rb:33
  def reset; end
end

# @api public
#
# source://parser-3.1.2.1/lib/parser/context.rb:19
Parser::Context::FLAGS = T.let(T.unsafe(nil), Array)

# Stack that holds names of current arguments,
# i.e. while parsing
#   def m1(a = (def m2(b = def m3(c = 1); end); end)); end
#                                   ^
# stack is [:a, :b, :c]
#
# Emulates `p->cur_arg` in MRI's parse.y
#
# @api private
#
# source://parser-3.1.2.1/lib/parser/current_arg_stack.rb:14
class Parser::CurrentArgStack
  # @api private
  # @return [CurrentArgStack] a new instance of CurrentArgStack
  #
  # source://parser-3.1.2.1/lib/parser/current_arg_stack.rb:17
  def initialize; end

  # @api private
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/current_arg_stack.rb:22
  def empty?; end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/current_arg_stack.rb:34
  def pop; end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/current_arg_stack.rb:26
  def push(value); end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/current_arg_stack.rb:38
  def reset; end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/current_arg_stack.rb:30
  def set(value); end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/current_arg_stack.rb:15
  def stack; end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/current_arg_stack.rb:42
  def top; end
end

# source://parser-3.1.2.1/lib/parser/current.rb:84
Parser::CurrentRuby = Parser::Ruby27

# @api private
#
# source://parser-3.1.2.1/lib/parser/deprecation.rb:7
module Parser::Deprecation
  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/deprecation.rb:9
  def warn_of_deprecation; end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/deprecation.rb:8
  def warned_of_deprecation=(_arg0); end
end

# @api public
#
# source://parser-3.1.2.1/lib/parser/diagnostic.rb:31
class Parser::Diagnostic
  # @api public
  # @param level [Symbol]
  # @param reason [Symbol]
  # @param arguments [Hash]
  # @param location [Parser::Source::Range]
  # @param highlights [Array<Parser::Source::Range>]
  # @return [Diagnostic] a new instance of Diagnostic
  #
  # source://parser-3.1.2.1/lib/parser/diagnostic.rb:49
  def initialize(level, reason, arguments, location, highlights = T.unsafe(nil)); end

  # @api public
  # @return [Symbol] extended arguments that describe the error
  # @see Parser::MESSAGES
  #
  # source://parser-3.1.2.1/lib/parser/diagnostic.rb:39
  def arguments; end

  # Supplementary error-related source ranges.
  #
  # @api public
  # @return [Array<Parser::Source::Range>]
  #
  # source://parser-3.1.2.1/lib/parser/diagnostic.rb:40
  def highlights; end

  # @api public
  # @return [Symbol] diagnostic level
  # @see LEVELS
  #
  # source://parser-3.1.2.1/lib/parser/diagnostic.rb:39
  def level; end

  # Main error-related source range.
  #
  # @api public
  # @return [Parser::Source::Range]
  #
  # source://parser-3.1.2.1/lib/parser/diagnostic.rb:40
  def location; end

  # @api public
  # @return [String] the rendered message.
  #
  # source://parser-3.1.2.1/lib/parser/diagnostic.rb:69
  def message; end

  # @api public
  # @return [Symbol] reason for error
  # @see Parser::MESSAGES
  #
  # source://parser-3.1.2.1/lib/parser/diagnostic.rb:39
  def reason; end

  # Renders the diagnostic message as a clang-like diagnostic.
  #
  # @api public
  # @example
  #   diagnostic.render # =>
  #   # [
  #   #   "(fragment:0):1:5: error: unexpected token $end",
  #   #   "foo +",
  #   #   "    ^"
  #   # ]
  # @return [Array<String>]
  #
  # source://parser-3.1.2.1/lib/parser/diagnostic.rb:86
  def render; end

  private

  # If necessary, shrink a `Range` so as to include only the first line.
  #
  # @api public
  # @return [Parser::Source::Range]
  #
  # source://parser-3.1.2.1/lib/parser/diagnostic.rb:142
  def first_line_only(range); end

  # If necessary, shrink a `Range` so as to include only the last line.
  #
  # @api public
  # @return [Parser::Source::Range]
  #
  # source://parser-3.1.2.1/lib/parser/diagnostic.rb:155
  def last_line_only(range); end

  # Renders one source line in clang diagnostic style, with highlights.
  #
  # @api public
  # @return [Array<String>]
  #
  # source://parser-3.1.2.1/lib/parser/diagnostic.rb:110
  def render_line(range, ellipsis = T.unsafe(nil), range_end = T.unsafe(nil)); end
end

# {Parser::Diagnostic::Engine} provides a basic API for dealing with
# diagnostics by delegating them to registered consumers.
#
# @api public
# @example
#   buffer      = Parser::Source::Buffer.new(__FILE__, source: 'foobar')
#
#   consumer = lambda do |diagnostic|
#   puts diagnostic.message
#   end
#
#   engine     = Parser::Diagnostic::Engine.new(consumer)
#   diagnostic = Parser::Diagnostic.new(
#   :warning, :unexpected_token, { :token => 'abc' }, buffer, 1..2)
#
#   engine.process(diagnostic) # => "unexpected token abc"
#
# source://parser-3.1.2.1/lib/parser/diagnostic/engine.rb:36
class Parser::Diagnostic::Engine
  # @api public
  # @param consumer [#call(Diagnostic)]
  # @return [Engine] a new instance of Engine
  #
  # source://parser-3.1.2.1/lib/parser/diagnostic/engine.rb:45
  def initialize(consumer = T.unsafe(nil)); end

  # When set to `true` any error that is encountered will result in
  # {Parser::SyntaxError} being raised.
  #
  # @api public
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/diagnostic/engine.rb:39
  def all_errors_are_fatal; end

  # When set to `true` any error that is encountered will result in
  # {Parser::SyntaxError} being raised.
  #
  # @api public
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/diagnostic/engine.rb:39
  def all_errors_are_fatal=(_arg0); end

  # @api public
  # @return [#call(Diagnostic)]
  #
  # source://parser-3.1.2.1/lib/parser/diagnostic/engine.rb:37
  def consumer; end

  # @api public
  # @return [#call(Diagnostic)]
  #
  # source://parser-3.1.2.1/lib/parser/diagnostic/engine.rb:37
  def consumer=(_arg0); end

  # When set to `true` warnings will be ignored.
  #
  # @api public
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/diagnostic/engine.rb:40
  def ignore_warnings; end

  # When set to `true` warnings will be ignored.
  #
  # @api public
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/diagnostic/engine.rb:40
  def ignore_warnings=(_arg0); end

  # Processes a `diagnostic`:
  #   * Passes the diagnostic to the consumer, if it's not a warning when
  #     `ignore_warnings` is set.
  #   * After that, raises {Parser::SyntaxError} when `all_errors_are_fatal`
  #     is set to true.
  #
  # @api public
  # @param diagnostic [Parser::Diagnostic]
  # @return [Parser::Diagnostic::Engine]
  # @see ignore?
  # @see raise?
  #
  # source://parser-3.1.2.1/lib/parser/diagnostic/engine.rb:64
  def process(diagnostic); end

  protected

  # Checks whether `diagnostic` should be ignored.
  #
  # @api public
  # @param diagnostic [Parser::Diagnostic]
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/diagnostic/engine.rb:86
  def ignore?(diagnostic); end

  # Checks whether `diagnostic` should be raised as an exception.
  #
  # @api public
  # @param diagnostic [Parser::Diagnostic]
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/diagnostic/engine.rb:97
  def raise?(diagnostic); end
end

# Collection of the available diagnostic levels.
#
# @api public
# @return [Array]
#
# source://parser-3.1.2.1/lib/parser/diagnostic.rb:37
Parser::Diagnostic::LEVELS = T.let(T.unsafe(nil), Array)

# line 3 "lib/parser/lexer.rl"
#
# === BEFORE YOU START ===
#
# Read the Ruby Hacking Guide chapter 11, available in English at
# http://whitequark.org/blog/2013/04/01/ruby-hacking-guide-ch-11-finite-state-lexer/
#
# Remember two things about Ragel scanners:
#
#   1) Longest match wins.
#
#   2) If two matches have the same length, the first
#      in source code wins.
#
# General rules of making Ragel and Bison happy:
#
#  * `p` (position) and `@te` contain the index of the character
#    they're pointing to ("current"), plus one. `@ts` contains the index
#    of the corresponding character. The code for extracting matched token is:
#
#       @source_buffer.slice(@ts...@te)
#
#  * If your input is `foooooooobar` and the rule is:
#
#       'f' 'o'+
#
#    the result will be:
#
#       foooooooobar
#       ^ ts=0   ^ p=te=9
#
#  * A Ragel lexer action should not emit more than one token, unless
#    you know what you are doing.
#
#  * All Ragel commands (fnext, fgoto, ...) end with a semicolon.
#
#  * If an action emits the token and transitions to another state, use
#    these Ragel commands:
#
#       emit($whatever)
#       fnext $next_state; fbreak;
#
#    If you perform `fgoto` in an action which does not emit a token nor
#    rewinds the stream pointer, the parser's side-effectful,
#    context-sensitive lookahead actions will break in a hard to detect
#    and debug way.
#
#  * If an action does not emit a token:
#
#       fgoto $next_state;
#
#  * If an action features lookbehind, i.e. matches characters with the
#    intent of passing them to another action:
#
#       p = @ts - 1
#       fgoto $next_state;
#
#    or, if the lookbehind consists of a single character:
#
#       fhold; fgoto $next_state;
#
#  * Ragel merges actions. So, if you have `e_lparen = '(' %act` and
#    `c_lparen = '('` and a lexer action `e_lparen | c_lparen`, the result
#    _will_ invoke the action `act`.
#
#    e_something stands for "something with **e**mbedded action".
#
#  * EOF is explicit and is matched by `c_eof`. If you want to introspect
#    the state of the lexer, add this rule to the state:
#
#       c_eof => do_eof;
#
#  * If you proceed past EOF, the lexer will complain:
#
#       NoMethodError: undefined method `ord' for nil:NilClass
#
# @api public
#
# source://parser-3.1.2.1/lib/parser/lexer.rb:82
class Parser::Lexer
  # @api public
  # @return [Lexer] a new instance of Lexer
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:11148
  def initialize(version); end

  # Return next token: [type, value].
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:11303
  def advance; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:11142
  def cmdarg; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:11142
  def cmdarg=(_arg0); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:11146
  def cmdarg_stack; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:11142
  def command_start; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:11142
  def command_start=(_arg0); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:11144
  def comments; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:11144
  def comments=(_arg0); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:11142
  def cond; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:11142
  def cond=(_arg0); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:11146
  def cond_stack; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:11142
  def context; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:11142
  def context=(_arg0); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:11295
  def dedent_level; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:11138
  def diagnostics; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:11138
  def diagnostics=(_arg0); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:11245
  def encoding; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:11140
  def force_utf32; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:11140
  def force_utf32=(_arg0); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:11146
  def lambda_stack; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:11146
  def paren_nest; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:11282
  def pop_cmdarg; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:11291
  def pop_cond; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:11277
  def push_cmdarg; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:11286
  def push_cond; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:11159
  def reset(reset_state = T.unsafe(nil)); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:11136
  def source_buffer; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:11224
  def source_buffer=(source_buffer); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:11269
  def state; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:11273
  def state=(state); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:11139
  def static_env; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:11139
  def static_env=(_arg0); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:11144
  def tokens; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:11144
  def tokens=(_arg0); end

  protected

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:24883
  def arg_or_cmdarg(cmd_state); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:24903
  def diagnostic(type, reason, arguments = T.unsafe(nil), location = T.unsafe(nil), highlights = T.unsafe(nil)); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:24857
  def emit(type, value = T.unsafe(nil), s = T.unsafe(nil), e = T.unsafe(nil)); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:24891
  def emit_comment(s = T.unsafe(nil), e = T.unsafe(nil)); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:24873
  def emit_do(do_block = T.unsafe(nil)); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:24867
  def emit_table(table, s = T.unsafe(nil), e = T.unsafe(nil)); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:24845
  def encode_escape(ord); end

  # @api public
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:24832
  def eof_codepoint?(point); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:24946
  def literal; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:24918
  def next_state_for_literal(literal); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:24950
  def pop_literal; end

  # === LITERAL STACK ===
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:24912
  def push_literal(*args); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:24853
  def range(s = T.unsafe(nil), e = T.unsafe(nil)); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:24840
  def stack_pop; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:24849
  def tok(s = T.unsafe(nil), e = T.unsafe(nil)); end

  # @api public
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/lexer.rb:24836
  def version?(*versions); end

  class << self
    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11080
    def lex_en_expr_arg; end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11080
    def lex_en_expr_arg=(_arg0); end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11096
    def lex_en_expr_beg; end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11096
    def lex_en_expr_beg=(_arg0); end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11084
    def lex_en_expr_cmdarg; end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11084
    def lex_en_expr_cmdarg=(_arg0); end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11076
    def lex_en_expr_dot; end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11076
    def lex_en_expr_dot=(_arg0); end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11108
    def lex_en_expr_end; end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11108
    def lex_en_expr_end=(_arg0); end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11088
    def lex_en_expr_endarg; end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11088
    def lex_en_expr_endarg=(_arg0); end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11072
    def lex_en_expr_endfn; end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11072
    def lex_en_expr_endfn=(_arg0); end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11068
    def lex_en_expr_fname; end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11068
    def lex_en_expr_fname=(_arg0); end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11100
    def lex_en_expr_labelarg; end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11100
    def lex_en_expr_labelarg=(_arg0); end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11092
    def lex_en_expr_mid; end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11092
    def lex_en_expr_mid=(_arg0); end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11104
    def lex_en_expr_value; end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11104
    def lex_en_expr_value=(_arg0); end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11064
    def lex_en_expr_variable; end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11064
    def lex_en_expr_variable=(_arg0); end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11044
    def lex_en_interp_backslash_delimited; end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11044
    def lex_en_interp_backslash_delimited=(_arg0); end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11052
    def lex_en_interp_backslash_delimited_words; end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11052
    def lex_en_interp_backslash_delimited_words=(_arg0); end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11032
    def lex_en_interp_string; end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11032
    def lex_en_interp_string=(_arg0); end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11028
    def lex_en_interp_words; end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11028
    def lex_en_interp_words=(_arg0); end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11112
    def lex_en_leading_dot; end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11112
    def lex_en_leading_dot=(_arg0); end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11120
    def lex_en_line_begin; end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11120
    def lex_en_line_begin=(_arg0); end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11116
    def lex_en_line_comment; end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11116
    def lex_en_line_comment=(_arg0); end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11048
    def lex_en_plain_backslash_delimited; end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11048
    def lex_en_plain_backslash_delimited=(_arg0); end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11056
    def lex_en_plain_backslash_delimited_words; end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11056
    def lex_en_plain_backslash_delimited_words=(_arg0); end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11040
    def lex_en_plain_string; end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11040
    def lex_en_plain_string=(_arg0); end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11036
    def lex_en_plain_words; end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11036
    def lex_en_plain_words=(_arg0); end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11060
    def lex_en_regexp_modifiers; end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11060
    def lex_en_regexp_modifiers=(_arg0); end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11023
    def lex_error; end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11023
    def lex_error=(_arg0); end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11019
    def lex_start; end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:11019
    def lex_start=(_arg0); end

    private

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:10886
    def _lex_eof_trans; end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:10886
    def _lex_eof_trans=(_arg0); end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:10753
    def _lex_from_state_actions; end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:10753
    def _lex_from_state_actions=(_arg0); end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:604
    def _lex_index_offsets; end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:604
    def _lex_index_offsets=(_arg0); end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:737
    def _lex_indicies; end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:737
    def _lex_indicies=(_arg0); end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:471
    def _lex_key_spans; end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:471
    def _lex_key_spans=(_arg0); end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:10620
    def _lex_to_state_actions; end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:10620
    def _lex_to_state_actions=(_arg0); end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:10420
    def _lex_trans_actions; end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:10420
    def _lex_trans_actions=(_arg0); end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:87
    def _lex_trans_keys; end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:87
    def _lex_trans_keys=(_arg0); end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:10220
    def _lex_trans_targs; end

    # @api public
    #
    # source://parser-3.1.2.1/lib/parser/lexer.rb:10220
    def _lex_trans_targs=(_arg0); end
  end
end

# source://parser-3.1.2.1/lib/parser/lexer/dedenter.rb:5
class Parser::Lexer::Dedenter
  # source://parser-3.1.2.1/lib/parser/lexer/dedenter.rb:9
  def initialize(dedent_level); end

  # source://parser-3.1.2.1/lib/parser/lexer/dedenter.rb:36
  def dedent(string); end

  # source://parser-3.1.2.1/lib/parser/lexer/dedenter.rb:83
  def interrupt; end
end

# source://parser-3.1.2.1/lib/parser/lexer/dedenter.rb:7
Parser::Lexer::Dedenter::TAB_WIDTH = T.let(T.unsafe(nil), Integer)

# %
#
# @api public
#
# source://parser-3.1.2.1/lib/parser/lexer.rb:11128
Parser::Lexer::ESCAPES = T.let(T.unsafe(nil), Hash)

# @api public
#
# source://parser-3.1.2.1/lib/parser/lexer.rb:24991
Parser::Lexer::KEYWORDS = T.let(T.unsafe(nil), Hash)

# @api public
#
# source://parser-3.1.2.1/lib/parser/lexer.rb:24998
Parser::Lexer::KEYWORDS_BEGIN = T.let(T.unsafe(nil), Hash)

# @api public
#
# source://parser-3.1.2.1/lib/parser/lexer.rb:11249
Parser::Lexer::LEX_STATES = T.let(T.unsafe(nil), Hash)

# source://parser-3.1.2.1/lib/parser/lexer/literal.rb:6
class Parser::Lexer::Literal
  # source://parser-3.1.2.1/lib/parser/lexer/literal.rb:40
  def initialize(lexer, str_type, delimiter, str_s, heredoc_e = T.unsafe(nil), indent = T.unsafe(nil), dedent_body = T.unsafe(nil), label_allowed = T.unsafe(nil)); end

  # source://parser-3.1.2.1/lib/parser/lexer/literal.rb:114
  def backslash_delimited?; end

  # source://parser-3.1.2.1/lib/parser/lexer/literal.rb:37
  def dedent_level; end

  # source://parser-3.1.2.1/lib/parser/lexer/literal.rb:189
  def end_interp_brace_and_try_closing; end

  # source://parser-3.1.2.1/lib/parser/lexer/literal.rb:216
  def extend_content; end

  # source://parser-3.1.2.1/lib/parser/lexer/literal.rb:220
  def extend_space(ts, te); end

  # source://parser-3.1.2.1/lib/parser/lexer/literal.rb:195
  def extend_string(string, ts, te); end

  # source://parser-3.1.2.1/lib/parser/lexer/literal.rb:202
  def flush_string; end

  # source://parser-3.1.2.1/lib/parser/lexer/literal.rb:102
  def heredoc?; end

  # source://parser-3.1.2.1/lib/parser/lexer/literal.rb:37
  def heredoc_e; end

  # source://parser-3.1.2.1/lib/parser/lexer/literal.rb:166
  def infer_indent_level(line); end

  # source://parser-3.1.2.1/lib/parser/lexer/literal.rb:89
  def interpolate?; end

  # source://parser-3.1.2.1/lib/parser/lexer/literal.rb:122
  def munge_escape?(character); end

  # source://parser-3.1.2.1/lib/parser/lexer/literal.rb:132
  def nest_and_try_closing(delimiter, ts, te, lookahead = T.unsafe(nil)); end

  # source://parser-3.1.2.1/lib/parser/lexer/literal.rb:106
  def plain_heredoc?; end

  # source://parser-3.1.2.1/lib/parser/lexer/literal.rb:98
  def regexp?; end

  # source://parser-3.1.2.1/lib/parser/lexer/literal.rb:38
  def saved_herebody_s; end

  # source://parser-3.1.2.1/lib/parser/lexer/literal.rb:38
  def saved_herebody_s=(_arg0); end

  # source://parser-3.1.2.1/lib/parser/lexer/literal.rb:110
  def squiggly_heredoc?; end

  # source://parser-3.1.2.1/lib/parser/lexer/literal.rb:185
  def start_interp_brace; end

  # source://parser-3.1.2.1/lib/parser/lexer/literal.rb:37
  def str_s; end

  # source://parser-3.1.2.1/lib/parser/lexer/literal.rb:230
  def supports_line_continuation_via_slash?; end

  # source://parser-3.1.2.1/lib/parser/lexer/literal.rb:118
  def type; end

  # source://parser-3.1.2.1/lib/parser/lexer/literal.rb:93
  def words?; end

  protected

  # source://parser-3.1.2.1/lib/parser/lexer/literal.rb:248
  def clear_buffer; end

  # source://parser-3.1.2.1/lib/parser/lexer/literal.rb:244
  def coerce_encoding(string); end

  # source://parser-3.1.2.1/lib/parser/lexer/literal.rb:236
  def delimiter?(delimiter); end

  # source://parser-3.1.2.1/lib/parser/lexer/literal.rb:264
  def emit(token, type, s, e); end

  # source://parser-3.1.2.1/lib/parser/lexer/literal.rb:259
  def emit_start_tok; end
end

# source://parser-3.1.2.1/lib/parser/lexer/literal.rb:7
Parser::Lexer::Literal::DELIMITERS = T.let(T.unsafe(nil), Hash)

# source://parser-3.1.2.1/lib/parser/lexer/literal.rb:9
Parser::Lexer::Literal::TYPES = T.let(T.unsafe(nil), Hash)

# Mapping of strings to parser tokens.
#
# @api public
#
# source://parser-3.1.2.1/lib/parser/lexer.rb:24965
Parser::Lexer::PUNCTUATION = T.let(T.unsafe(nil), Hash)

# @api public
#
# source://parser-3.1.2.1/lib/parser/lexer.rb:24985
Parser::Lexer::PUNCTUATION_BEGIN = T.let(T.unsafe(nil), Hash)

# @api public
#
# source://parser-3.1.2.1/lib/parser/lexer.rb:11134
Parser::Lexer::REGEXP_META_CHARACTERS = T.let(T.unsafe(nil), Regexp)

# source://parser-3.1.2.1/lib/parser/lexer/stack_state.rb:5
class Parser::Lexer::StackState
  # source://parser-3.1.2.1/lib/parser/lexer/stack_state.rb:6
  def initialize(name); end

  # source://parser-3.1.2.1/lib/parser/lexer/stack_state.rb:34
  def active?; end

  # source://parser-3.1.2.1/lib/parser/lexer/stack_state.rb:11
  def clear; end

  # source://parser-3.1.2.1/lib/parser/lexer/stack_state.rb:38
  def empty?; end

  # source://parser-3.1.2.1/lib/parser/lexer/stack_state.rb:42
  def inspect; end

  # source://parser-3.1.2.1/lib/parser/lexer/stack_state.rb:29
  def lexpop; end

  # source://parser-3.1.2.1/lib/parser/lexer/stack_state.rb:22
  def pop; end

  # source://parser-3.1.2.1/lib/parser/lexer/stack_state.rb:15
  def push(bit); end

  # source://parser-3.1.2.1/lib/parser/lexer/stack_state.rb:42
  def to_s; end
end

# Diagnostic messages (errors, warnings and notices) that can be generated.
#
# @api public
# @see Diagnostic
#
# source://parser-3.1.2.1/lib/parser/messages.rb:11
Parser::MESSAGES = T.let(T.unsafe(nil), Hash)

# Holds p->max_numparam from parse.y
#
# @api private
#
# source://parser-3.1.2.1/lib/parser/max_numparam_stack.rb:8
class Parser::MaxNumparamStack
  # @api private
  # @return [MaxNumparamStack] a new instance of MaxNumparamStack
  #
  # source://parser-3.1.2.1/lib/parser/max_numparam_stack.rb:13
  def initialize; end

  # @api private
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/max_numparam_stack.rb:17
  def empty?; end

  # @api private
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/max_numparam_stack.rb:29
  def has_numparams?; end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/max_numparam_stack.rb:21
  def has_ordinary_params!; end

  # @api private
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/max_numparam_stack.rb:25
  def has_ordinary_params?; end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/max_numparam_stack.rb:45
  def pop; end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/max_numparam_stack.rb:41
  def push(static:); end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/max_numparam_stack.rb:33
  def register(numparam); end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/max_numparam_stack.rb:9
  def stack; end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/max_numparam_stack.rb:37
  def top; end

  private

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/max_numparam_stack.rb:51
  def set(value); end
end

# @api private
#
# source://parser-3.1.2.1/lib/parser/max_numparam_stack.rb:11
Parser::MaxNumparamStack::ORDINARY_PARAMS = T.let(T.unsafe(nil), Integer)

# @api private
#
# source://parser-3.1.2.1/lib/parser/messages.rb:105
module Parser::Messages
  class << self
    # Formats the message, returns a raw template if there's nothing to interpolate
    #
    # Code like `format("", {})` gives a warning, and so this method tries interpolating
    # only if `arguments` hash is not empty.
    #
    # @api private
    #
    # source://parser-3.1.2.1/lib/parser/messages.rb:112
    def compile(reason, arguments); end
  end
end

# Parser metadata
#
# @api public
#
# source://parser-3.1.2.1/lib/parser/meta.rb:5
module Parser::Meta; end

# All node types that parser can produce. Not all parser versions
# will be able to produce every possible node.
#
# @api public
#
# source://parser-3.1.2.1/lib/parser/meta.rb:9
Parser::Meta::NODE_TYPES = T.let(T.unsafe(nil), Set)

# {Parser::Rewriter} is deprecated. Use {Parser::TreeRewriter} instead.
# It has a backwards compatible API and uses {Parser::Source::TreeRewriter}
# instead of {Parser::Source::Rewriter}.
# Please check the documentation for {Parser::Source::Rewriter} for details.
#
# @api public
# @deprecated Use {Parser::TreeRewriter}
#
# source://parser-3.1.2.1/lib/parser/rewriter.rb:22
class Parser::Rewriter < ::Parser::AST::Processor
  extend ::Parser::Deprecation

  # @api public
  # @return [Rewriter] a new instance of Rewriter
  #
  # source://parser-3.1.2.1/lib/parser/rewriter.rb:98
  def initialize(*_arg0); end

  # Returns `true` if the specified node is an assignment node, returns false
  # otherwise.
  #
  # @api public
  # @param node [Parser::AST::Node]
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/rewriter.rb:38
  def assignment?(node); end

  # Inserts new code after the given source range.
  #
  # @api public
  # @param range [Parser::Source::Range]
  # @param content [String]
  #
  # source://parser-3.1.2.1/lib/parser/rewriter.rb:77
  def insert_after(range, content); end

  # Inserts new code before the given source range.
  #
  # @api public
  # @param range [Parser::Source::Range]
  # @param content [String]
  #
  # source://parser-3.1.2.1/lib/parser/rewriter.rb:67
  def insert_before(range, content); end

  # Removes the source range.
  #
  # @api public
  # @param range [Parser::Source::Range]
  #
  # source://parser-3.1.2.1/lib/parser/rewriter.rb:47
  def remove(range); end

  # Replaces the code of the source range `range` with `content`.
  #
  # @api public
  # @param range [Parser::Source::Range]
  # @param content [String]
  #
  # source://parser-3.1.2.1/lib/parser/rewriter.rb:87
  def replace(range, content); end

  # Rewrites the AST/source buffer and returns a String containing the new
  # version.
  #
  # @api public
  # @param source_buffer [Parser::Source::Buffer]
  # @param ast [Parser::AST::Node]
  # @return [String]
  #
  # source://parser-3.1.2.1/lib/parser/rewriter.rb:23
  def rewrite(source_buffer, ast); end

  # Wraps the given source range with the given values.
  #
  # @api public
  # @param range [Parser::Source::Range]
  # @param content [String]
  #
  # source://parser-3.1.2.1/lib/parser/rewriter.rb:57
  def wrap(range, before, after); end
end

# @api public
#
# source://parser-3.1.2.1/lib/parser/rewriter.rb:91
Parser::Rewriter::DEPRECATION_WARNING = T.let(T.unsafe(nil), String)

# @api public
#
# source://parser-3.1.2.1/lib/parser/ruby27.rb:14
class Parser::Ruby27 < ::Parser::Base
  # reduce 0 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:3875
  def _reduce_1(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:3929
  def _reduce_10(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4505
  def _reduce_100(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4515
  def _reduce_101(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4521
  def _reduce_102(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4531
  def _reduce_103(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4538
  def _reduce_104(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4545
  def _reduce_105(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4551
  def _reduce_106(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4557
  def _reduce_107(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4563
  def _reduce_108(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4569
  def _reduce_109(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:3935
  def _reduce_11(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4575
  def _reduce_110(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4581
  def _reduce_111(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4587
  def _reduce_112(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4594
  def _reduce_113(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4601
  def _reduce_114(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4607
  def _reduce_115(val, _values, result); end

  # reduce 116 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4615
  def _reduce_117(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4621
  def _reduce_118(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4627
  def _reduce_119(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:3952
  def _reduce_12(val, _values, result); end

  # reduce 124 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4643
  def _reduce_125(val, _values, result); end

  # reduce 126 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4651
  def _reduce_127(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4657
  def _reduce_128(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4663
  def _reduce_129(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:3958
  def _reduce_13(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:3964
  def _reduce_14(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:3970
  def _reduce_15(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:3976
  def _reduce_16(val, _values, result); end

  # reduce 17 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:3984
  def _reduce_18(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:3990
  def _reduce_19(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:3882
  def _reduce_2(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:3996
  def _reduce_20(val, _values, result); end

  # reduce 200 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4811
  def _reduce_201(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4817
  def _reduce_202(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4823
  def _reduce_203(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4832
  def _reduce_204(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4841
  def _reduce_205(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4850
  def _reduce_206(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4859
  def _reduce_207(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4867
  def _reduce_208(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4875
  def _reduce_209(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4002
  def _reduce_21(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4881
  def _reduce_210(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4887
  def _reduce_211(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4893
  def _reduce_212(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4899
  def _reduce_213(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4905
  def _reduce_214(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4911
  def _reduce_215(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4917
  def _reduce_216(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4923
  def _reduce_217(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4929
  def _reduce_218(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4935
  def _reduce_219(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4010
  def _reduce_22(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4941
  def _reduce_220(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4947
  def _reduce_221(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4953
  def _reduce_222(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4961
  def _reduce_223(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4967
  def _reduce_224(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4973
  def _reduce_225(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4979
  def _reduce_226(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4985
  def _reduce_227(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4991
  def _reduce_228(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4018
  def _reduce_23(val, _values, result); end

  # reduce 229 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4999
  def _reduce_230(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5005
  def _reduce_231(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5011
  def _reduce_232(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5017
  def _reduce_233(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5023
  def _reduce_234(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5029
  def _reduce_235(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5035
  def _reduce_236(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5041
  def _reduce_237(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5047
  def _reduce_238(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5053
  def _reduce_239(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4024
  def _reduce_24(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5059
  def _reduce_240(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5065
  def _reduce_241(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5071
  def _reduce_242(val, _values, result); end

  # reduce 247 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5088
  def _reduce_248(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5094
  def _reduce_249(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4030
  def _reduce_25(val, _values, result); end

  # reduce 252 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5106
  def _reduce_253(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5112
  def _reduce_254(val, _values, result); end

  # reduce 255 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5120
  def _reduce_256(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5130
  def _reduce_257(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5136
  def _reduce_258(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5146
  def _reduce_259(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4037
  def _reduce_26(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5156
  def _reduce_260(val, _values, result); end

  # reduce 261 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5164
  def _reduce_262(val, _values, result); end

  # reduce 264 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5174
  def _reduce_265(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5180
  def _reduce_266(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5186
  def _reduce_267(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5192
  def _reduce_268(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5198
  def _reduce_269(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4044
  def _reduce_27(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5205
  def _reduce_270(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5213
  def _reduce_271(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5219
  def _reduce_272(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5246
  def _reduce_273(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5267
  def _reduce_274(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5273
  def _reduce_275(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5279
  def _reduce_276(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5285
  def _reduce_277(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5291
  def _reduce_278(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5297
  def _reduce_279(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4050
  def _reduce_28(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5303
  def _reduce_280(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5309
  def _reduce_281(val, _values, result); end

  # reduce 282 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5317
  def _reduce_283(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5323
  def _reduce_284(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5329
  def _reduce_285(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4056
  def _reduce_29(val, _values, result); end

  # reduce 295 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5355
  def _reduce_296(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5361
  def _reduce_297(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5367
  def _reduce_298(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5375
  def _reduce_299(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:3891
  def _reduce_3(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4066
  def _reduce_30(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5381
  def _reduce_300(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5387
  def _reduce_301(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5393
  def _reduce_302(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5399
  def _reduce_303(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5405
  def _reduce_304(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5411
  def _reduce_305(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5417
  def _reduce_306(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5423
  def _reduce_307(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5429
  def _reduce_308(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5435
  def _reduce_309(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5441
  def _reduce_310(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5447
  def _reduce_311(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5453
  def _reduce_312(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5460
  def _reduce_313(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5466
  def _reduce_314(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5472
  def _reduce_315(val, _values, result); end

  # reduce 316 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5484
  def _reduce_317(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5492
  def _reduce_318(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5499
  def _reduce_319(val, _values, result); end

  # reduce 31 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4074
  def _reduce_32(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5511
  def _reduce_320(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5520
  def _reduce_321(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5529
  def _reduce_322(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5535
  def _reduce_323(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5541
  def _reduce_324(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5551
  def _reduce_325(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5561
  def _reduce_326(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5571
  def _reduce_327(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5577
  def _reduce_328(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5584
  def _reduce_329(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4080
  def _reduce_33(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5601
  def _reduce_330(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5609
  def _reduce_331(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5621
  def _reduce_332(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5628
  def _reduce_333(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5643
  def _reduce_334(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5652
  def _reduce_335(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5663
  def _reduce_336(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5669
  def _reduce_337(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5678
  def _reduce_338(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5689
  def _reduce_339(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4087
  def _reduce_34(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5695
  def _reduce_340(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5701
  def _reduce_341(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5707
  def _reduce_342(val, _values, result); end

  # reduce 343 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5715
  def _reduce_344(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5721
  def _reduce_345(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5727
  def _reduce_346(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5733
  def _reduce_347(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4098
  def _reduce_35(val, _values, result); end

  # reduce 349 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5745
  def _reduce_350(val, _values, result); end

  # reduce 353 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5757
  def _reduce_354(val, _values, result); end

  # reduce 355 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5770
  def _reduce_356(val, _values, result); end

  # reduce 358 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5780
  def _reduce_359(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5786
  def _reduce_360(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5792
  def _reduce_361(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5798
  def _reduce_362(val, _values, result); end

  # reduce 363 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5806
  def _reduce_364(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5813
  def _reduce_365(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5821
  def _reduce_366(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5827
  def _reduce_367(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5833
  def _reduce_368(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5839
  def _reduce_369(val, _values, result); end

  # reduce 36 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4106
  def _reduce_37(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5845
  def _reduce_370(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5851
  def _reduce_371(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5857
  def _reduce_372(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5863
  def _reduce_373(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5869
  def _reduce_374(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5875
  def _reduce_375(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5881
  def _reduce_376(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5887
  def _reduce_377(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5896
  def _reduce_378(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5906
  def _reduce_379(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4112
  def _reduce_38(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5914
  def _reduce_380(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5923
  def _reduce_381(val, _values, result); end

  # reduce 382 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5933
  def _reduce_383(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5942
  def _reduce_384(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5952
  def _reduce_385(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5960
  def _reduce_386(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5969
  def _reduce_387(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5976
  def _reduce_388(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5984
  def _reduce_389(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4118
  def _reduce_39(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:5991
  def _reduce_390(val, _values, result); end

  # reduce 391 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6001
  def _reduce_392(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6007
  def _reduce_393(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6013
  def _reduce_394(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6021
  def _reduce_395(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6029
  def _reduce_396(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6035
  def _reduce_397(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6041
  def _reduce_398(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6047
  def _reduce_399(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:3897
  def _reduce_4(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4127
  def _reduce_40(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6053
  def _reduce_400(val, _values, result); end

  # reduce 401 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6062
  def _reduce_402(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6069
  def _reduce_403(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6075
  def _reduce_404(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6086
  def _reduce_405(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6093
  def _reduce_406(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6102
  def _reduce_407(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6109
  def _reduce_408(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6116
  def _reduce_409(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4136
  def _reduce_41(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6123
  def _reduce_410(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6130
  def _reduce_411(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6137
  def _reduce_412(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6144
  def _reduce_413(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6152
  def _reduce_414(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6160
  def _reduce_415(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6172
  def _reduce_416(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6183
  def _reduce_417(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6191
  def _reduce_418(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6199
  def _reduce_419(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4145
  def _reduce_42(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6207
  def _reduce_420(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6213
  def _reduce_421(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6221
  def _reduce_422(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6229
  def _reduce_423(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6237
  def _reduce_424(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6243
  def _reduce_425(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6249
  def _reduce_426(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6256
  def _reduce_427(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6263
  def _reduce_428(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6270
  def _reduce_429(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4153
  def _reduce_43(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6277
  def _reduce_430(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6284
  def _reduce_431(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6294
  def _reduce_432(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6301
  def _reduce_433(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6307
  def _reduce_434(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6318
  def _reduce_435(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6325
  def _reduce_436(val, _values, result); end

  # reduce 437 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6333
  def _reduce_438(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6345
  def _reduce_439(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4162
  def _reduce_44(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6353
  def _reduce_440(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6360
  def _reduce_441(val, _values, result); end

  # reduce 442 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6368
  def _reduce_443(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6374
  def _reduce_444(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6380
  def _reduce_445(val, _values, result); end

  # reduce 446 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6388
  def _reduce_447(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6398
  def _reduce_448(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6404
  def _reduce_449(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6410
  def _reduce_450(val, _values, result); end

  # reduce 451 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6418
  def _reduce_452(val, _values, result); end

  # reduce 453 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6426
  def _reduce_454(val, _values, result); end

  # reduce 455 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6434
  def _reduce_456(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6441
  def _reduce_457(val, _values, result); end

  # reduce 458 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6450
  def _reduce_459(val, _values, result); end

  # reduce 45 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4170
  def _reduce_46(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6458
  def _reduce_460(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6466
  def _reduce_461(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6473
  def _reduce_462(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6481
  def _reduce_463(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6489
  def _reduce_464(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6496
  def _reduce_465(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6502
  def _reduce_466(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6509
  def _reduce_467(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6515
  def _reduce_468(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6523
  def _reduce_469(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6531
  def _reduce_470(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6537
  def _reduce_471(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6543
  def _reduce_472(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6550
  def _reduce_473(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6556
  def _reduce_474(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6562
  def _reduce_475(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6568
  def _reduce_476(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6575
  def _reduce_477(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6582
  def _reduce_478(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6588
  def _reduce_479(val, _values, result); end

  # reduce 480 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6596
  def _reduce_481(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6606
  def _reduce_482(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6616
  def _reduce_483(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6623
  def _reduce_484(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6630
  def _reduce_485(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6637
  def _reduce_486(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6644
  def _reduce_487(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6650
  def _reduce_488(val, _values, result); end

  # reduce 48 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4184
  def _reduce_49(val, _values, result); end

  # reduce 489 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6658
  def _reduce_490(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6664
  def _reduce_491(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6670
  def _reduce_492(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6676
  def _reduce_493(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6682
  def _reduce_494(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6688
  def _reduce_495(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6694
  def _reduce_496(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6700
  def _reduce_497(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6706
  def _reduce_498(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6712
  def _reduce_499(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:3903
  def _reduce_5(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4190
  def _reduce_50(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6718
  def _reduce_500(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6724
  def _reduce_501(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6730
  def _reduce_502(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6736
  def _reduce_503(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6742
  def _reduce_504(val, _values, result); end

  # reduce 505 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6750
  def _reduce_506(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6756
  def _reduce_507(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6762
  def _reduce_508(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6768
  def _reduce_509(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4196
  def _reduce_51(val, _values, result); end

  # reduce 512 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6780
  def _reduce_513(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6786
  def _reduce_514(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4202
  def _reduce_52(val, _values, result); end

  # reduce 522 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6808
  def _reduce_523(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6814
  def _reduce_524(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6821
  def _reduce_525(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6833
  def _reduce_526(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6839
  def _reduce_527(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6851
  def _reduce_528(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6857
  def _reduce_529(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4208
  def _reduce_53(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6863
  def _reduce_530(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6869
  def _reduce_531(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6884
  def _reduce_532(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6890
  def _reduce_533(val, _values, result); end

  # reduce 535 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6900
  def _reduce_536(val, _values, result); end

  # reduce 537 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6908
  def _reduce_538(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4219
  def _reduce_54(val, _values, result); end

  # reduce 541 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6920
  def _reduce_542(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6926
  def _reduce_543(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6932
  def _reduce_544(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6938
  def _reduce_545(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6945
  def _reduce_546(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6952
  def _reduce_547(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6958
  def _reduce_548(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6965
  def _reduce_549(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6972
  def _reduce_550(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6978
  def _reduce_551(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6984
  def _reduce_552(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6990
  def _reduce_553(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:6996
  def _reduce_554(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7002
  def _reduce_555(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7008
  def _reduce_556(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7014
  def _reduce_557(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7020
  def _reduce_558(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7026
  def _reduce_559(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7032
  def _reduce_560(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7038
  def _reduce_561(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7044
  def _reduce_562(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7050
  def _reduce_563(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7056
  def _reduce_564(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7062
  def _reduce_565(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7068
  def _reduce_566(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7074
  def _reduce_567(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7080
  def _reduce_568(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7086
  def _reduce_569(val, _values, result); end

  # reduce 56 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4235
  def _reduce_57(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7092
  def _reduce_570(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7098
  def _reduce_571(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7104
  def _reduce_572(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7111
  def _reduce_573(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7120
  def _reduce_574(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7126
  def _reduce_575(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7132
  def _reduce_576(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4241
  def _reduce_58(val, _values, result); end

  # reduce 579 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7144
  def _reduce_580(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7151
  def _reduce_581(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7158
  def _reduce_582(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7164
  def _reduce_583(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7175
  def _reduce_584(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7182
  def _reduce_585(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7189
  def _reduce_586(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7196
  def _reduce_587(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7203
  def _reduce_588(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7209
  def _reduce_589(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7215
  def _reduce_590(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7221
  def _reduce_591(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7227
  def _reduce_592(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7233
  def _reduce_593(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7239
  def _reduce_594(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7245
  def _reduce_595(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7251
  def _reduce_596(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7257
  def _reduce_597(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7263
  def _reduce_598(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7269
  def _reduce_599(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:3909
  def _reduce_6(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7275
  def _reduce_600(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7281
  def _reduce_601(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7287
  def _reduce_602(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7293
  def _reduce_603(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7299
  def _reduce_604(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7305
  def _reduce_605(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7311
  def _reduce_606(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7317
  def _reduce_607(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7323
  def _reduce_608(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7329
  def _reduce_609(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7337
  def _reduce_610(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7345
  def _reduce_611(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7354
  def _reduce_612(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7361
  def _reduce_613(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7368
  def _reduce_614(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7374
  def _reduce_615(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7380
  def _reduce_616(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7386
  def _reduce_617(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7392
  def _reduce_618(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7398
  def _reduce_619(val, _values, result); end

  # reduce 61 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4254
  def _reduce_62(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7404
  def _reduce_620(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7410
  def _reduce_621(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7419
  def _reduce_622(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7429
  def _reduce_623(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7437
  def _reduce_624(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7446
  def _reduce_625(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7454
  def _reduce_626(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7463
  def _reduce_627(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7470
  def _reduce_628(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7478
  def _reduce_629(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4261
  def _reduce_63(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7487
  def _reduce_630(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7494
  def _reduce_631(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7502
  def _reduce_632(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7509
  def _reduce_633(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7517
  def _reduce_634(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7523
  def _reduce_635(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7529
  def _reduce_636(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7535
  def _reduce_637(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7541
  def _reduce_638(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7547
  def _reduce_639(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4268
  def _reduce_64(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7553
  def _reduce_640(val, _values, result); end

  # reduce 641 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7561
  def _reduce_642(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7571
  def _reduce_643(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7578
  def _reduce_644(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7585
  def _reduce_645(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7591
  def _reduce_646(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7597
  def _reduce_647(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7603
  def _reduce_648(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7617
  def _reduce_649(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7624
  def _reduce_650(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7631
  def _reduce_651(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7637
  def _reduce_652(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7643
  def _reduce_653(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7649
  def _reduce_654(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7655
  def _reduce_655(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7661
  def _reduce_656(val, _values, result); end

  # reduce 658 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7671
  def _reduce_659(val, _values, result); end

  # reduce 65 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4277
  def _reduce_66(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7677
  def _reduce_660(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7685
  def _reduce_661(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7691
  def _reduce_662(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7698
  def _reduce_663(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7705
  def _reduce_664(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7711
  def _reduce_665(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7717
  def _reduce_666(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7723
  def _reduce_667(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4284
  def _reduce_67(val, _values, result); end

  # reduce 669 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7733
  def _reduce_670(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7741
  def _reduce_671(val, _values, result); end

  # reduce 673 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7751
  def _reduce_674(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7759
  def _reduce_675(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7765
  def _reduce_676(val, _values, result); end

  # reduce 677 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7773
  def _reduce_678(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7779
  def _reduce_679(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4295
  def _reduce_68(val, _values, result); end

  # reduce 680 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7787
  def _reduce_681(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7793
  def _reduce_682(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7799
  def _reduce_683(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7805
  def _reduce_684(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7811
  def _reduce_685(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7817
  def _reduce_686(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4302
  def _reduce_69(val, _values, result); end

  # reduce 698 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7847
  def _reduce_699(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:3915
  def _reduce_7(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4313
  def _reduce_70(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7853
  def _reduce_700(val, _values, result); end

  # reduce 704 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7867
  def _reduce_705(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7873
  def _reduce_706(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7879
  def _reduce_707(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4320
  def _reduce_71(val, _values, result); end

  # reduce 710 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7891
  def _reduce_711(val, _values, result); end

  # reduce 714 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7903
  def _reduce_715(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4331
  def _reduce_72(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4338
  def _reduce_73(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4345
  def _reduce_74(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4352
  def _reduce_75(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4359
  def _reduce_76(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4366
  def _reduce_77(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4372
  def _reduce_78(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4378
  def _reduce_79(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4384
  def _reduce_80(val, _values, result); end

  # reduce 81 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4392
  def _reduce_82(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4399
  def _reduce_83(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4406
  def _reduce_84(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4414
  def _reduce_85(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4421
  def _reduce_86(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4429
  def _reduce_87(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4435
  def _reduce_88(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4442
  def _reduce_89(val, _values, result); end

  # reduce 8 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:3923
  def _reduce_9(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4448
  def _reduce_90(val, _values, result); end

  # reduce 91 omitted
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4457
  def _reduce_92(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4463
  def _reduce_93(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4469
  def _reduce_94(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4475
  def _reduce_95(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4481
  def _reduce_96(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4487
  def _reduce_97(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4493
  def _reduce_98(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:4499
  def _reduce_99(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:7909
  def _reduce_none(val, _values, result); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:21
  def default_encoding; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:32
  def local_pop; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:25
  def local_push; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:39
  def try_declare_numparam(node); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/ruby27.rb:17
  def version; end
end

# @api public
#
# source://parser-3.1.2.1/lib/parser/ruby27.rb:3476
Parser::Ruby27::Racc_arg = T.let(T.unsafe(nil), Array)

# @api public
#
# source://parser-3.1.2.1/lib/parser/ruby27.rb:3492
Parser::Ruby27::Racc_token_to_s_table = T.let(T.unsafe(nil), Array)

# @api public
#
# source://parser-3.1.2.1/lib/parser.rb:30
module Parser::Source; end

# A buffer with source code. {Buffer} contains the source code itself,
# associated location information (name and first line), and takes care
# of encoding.
#
# A source buffer is immutable once populated.
#
# @api public
#
# source://parser-3.1.2.1/lib/parser/source/buffer.rb:25
class Parser::Source::Buffer
  # @api public
  # @return [Buffer] a new instance of Buffer
  #
  # source://parser-3.1.2.1/lib/parser/source/buffer.rb:105
  def initialize(name, first_line = T.unsafe(nil), source: T.unsafe(nil)); end

  # Convert a character index into the source to a column number.
  #
  # @api private
  # @param position [Integer]
  # @return [Integer] column
  #
  # source://parser-3.1.2.1/lib/parser/source/buffer.rb:233
  def column_for_position(position); end

  # Convert a character index into the source to a `[line, column]` tuple.
  #
  # @api public
  # @param position [Integer]
  # @return [[Integer, Integer]] `[line, column]`
  #
  # source://parser-3.1.2.1/lib/parser/source/buffer.rb:208
  def decompose_position(position); end

  # First line of the buffer, 1 by default.
  #
  # @api public
  # @return [Integer] first line
  #
  # source://parser-3.1.2.1/lib/parser/source/buffer.rb:26
  def first_line; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/buffer.rb:303
  def freeze; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/buffer.rb:309
  def inspect; end

  # Number of last line in the buffer
  #
  # @api public
  # @return [Integer]
  #
  # source://parser-3.1.2.1/lib/parser/source/buffer.rb:298
  def last_line; end

  # Convert a character index into the source to a line number.
  #
  # @api private
  # @param position [Integer]
  # @return [Integer] line
  #
  # source://parser-3.1.2.1/lib/parser/source/buffer.rb:222
  def line_for_position(position); end

  # Extract line `lineno` as a new `Range`, taking `first_line` into account.
  #
  # @api public
  # @param lineno [Integer]
  # @raise [IndexError] if `lineno` is out of bounds
  # @return [Range]
  #
  # source://parser-3.1.2.1/lib/parser/source/buffer.rb:275
  def line_range(lineno); end

  # Buffer name. If the buffer was created from a file, the name corresponds
  # to relative path to the file.
  #
  # @api public
  # @return [String] buffer name
  #
  # source://parser-3.1.2.1/lib/parser/source/buffer.rb:26
  def name; end

  # Populate this buffer from a string without encoding autodetection.
  #
  # @api public
  # @param input [String]
  # @raise [ArgumentError] if already populated
  # @return [String]
  #
  # source://parser-3.1.2.1/lib/parser/source/buffer.rb:180
  def raw_source=(input); end

  # Populate this buffer from correspondingly named file.
  #
  # @api public
  # @example
  #   Parser::Source::Buffer.new('foo/bar.rb').read
  # @raise [ArgumentError] if already populated
  # @return [Buffer] self
  #
  # source://parser-3.1.2.1/lib/parser/source/buffer.rb:131
  def read; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/buffer.rb:194
  def slice(range); end

  # Source code contained in this buffer.
  #
  # @api public
  # @raise [RuntimeError] if buffer is not populated yet
  # @return [String] source code
  #
  # source://parser-3.1.2.1/lib/parser/source/buffer.rb:145
  def source; end

  # Populate this buffer from a string with encoding autodetection.
  # `input` is mutated if not frozen.
  #
  # @api public
  # @param input [String]
  # @raise [ArgumentError] if already populated
  # @raise [EncodingError] if `input` includes invalid byte sequence for the encoding
  # @return [String]
  #
  # source://parser-3.1.2.1/lib/parser/source/buffer.rb:162
  def source=(input); end

  # Extract line `lineno` from source, taking `first_line` into account.
  #
  # @api public
  # @param lineno [Integer]
  # @raise [IndexError] if `lineno` is out of bounds
  # @return [String]
  #
  # source://parser-3.1.2.1/lib/parser/source/buffer.rb:264
  def source_line(lineno); end

  # Return an `Array` of source code lines.
  #
  # @api public
  # @return [Array<String>]
  #
  # source://parser-3.1.2.1/lib/parser/source/buffer.rb:243
  def source_lines; end

  # @api public
  # @return [Range] A range covering the whole source
  #
  # source://parser-3.1.2.1/lib/parser/source/buffer.rb:289
  def source_range; end

  private

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/buffer.rb:339
  def bsearch(line_begins, position); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/buffer.rb:316
  def line_begins; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/buffer.rb:330
  def line_index_for_position(position); end

  class << self
    # Try to recognize encoding of `string` as Ruby would, i.e. by looking for
    # magic encoding comment or UTF-8 BOM. `string` can be in any encoding.
    #
    # @api public
    # @param string [String]
    # @return [String, nil] encoding name, if recognized
    #
    # source://parser-3.1.2.1/lib/parser/source/buffer.rb:51
    def recognize_encoding(string); end

    # Recognize encoding of `input` and process it so it could be lexed.
    #
    #  * If `input` does not contain BOM or magic encoding comment, it is
    #    kept in the original encoding.
    #  * If the detected encoding is binary, `input` is kept in binary.
    #  * Otherwise, `input` is re-encoded into UTF-8 and returned as a
    #    new string.
    #
    # This method mutates the encoding of `input`, but not its content.
    #
    # @api public
    # @param input [String]
    # @raise [EncodingError]
    # @return [String]
    #
    # source://parser-3.1.2.1/lib/parser/source/buffer.rb:90
    def reencode_string(input); end
  end
end

# @api private
#
# source://parser-3.1.2.1/lib/parser/source/buffer.rb:31
Parser::Source::Buffer::ENCODING_RE = T.let(T.unsafe(nil), Regexp)

# A comment in the source code.
#
# @api public
#
# source://parser-3.1.2.1/lib/parser/source/comment.rb:17
class Parser::Source::Comment
  # @api public
  # @param range [Parser::Source::Range]
  # @return [Comment] a new instance of Comment
  #
  # source://parser-3.1.2.1/lib/parser/source/comment.rb:67
  def initialize(range); end

  # Compares comments. Two comments are equal if they
  # correspond to the same source range.
  #
  # @api public
  # @param other [Object]
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/source/comment.rb:120
  def ==(other); end

  # @api public
  # @return [Boolean] true if this is a block comment.
  # @see #type
  #
  # source://parser-3.1.2.1/lib/parser/source/comment.rb:109
  def document?; end

  # @api public
  # @return [Boolean] true if this is an inline comment.
  # @see #type
  #
  # source://parser-3.1.2.1/lib/parser/source/comment.rb:101
  def inline?; end

  # @api public
  # @return [String] a human-readable representation of this comment
  #
  # source://parser-3.1.2.1/lib/parser/source/comment.rb:128
  def inspect; end

  # @api public
  # @return [Parser::Source::Range]
  #
  # source://parser-3.1.2.1/lib/parser/source/comment.rb:20
  def loc; end

  # @api public
  # @return [Parser::Source::Range]
  #
  # source://parser-3.1.2.1/lib/parser/source/comment.rb:20
  def location; end

  # @api public
  # @return [String]
  #
  # source://parser-3.1.2.1/lib/parser/source/comment.rb:18
  def text; end

  # Type of this comment.
  #
  #   * Inline comments correspond to `:inline`:
  #
  #         # whatever
  #
  #   * Block comments correspond to `:document`:
  #
  #         =begin
  #         hi i am a document
  #         =end
  #
  # @api public
  # @return [Symbol]
  #
  # source://parser-3.1.2.1/lib/parser/source/comment.rb:89
  def type; end

  class << self
    # Associate `comments` with `ast` nodes by their corresponding node.
    #
    # @api public
    # @deprecated Use {associate_locations}.
    # @param ast [Parser::AST::Node]
    # @param comments [Array<Comment>]
    # @return [Hash<Parser::AST::Node, Array<Comment>>]
    # @see Parser::Source::Comment::Associator#associate
    #
    # source://parser-3.1.2.1/lib/parser/source/comment.rb:32
    def associate(ast, comments); end

    # Associate `comments` with `ast` nodes using identity.
    #
    # @api public
    # @param ast [Parser::AST::Node]
    # @param comments [Array<Comment>]
    # @return [Hash<Parser::Source::Node, Array<Comment>>]
    # @see Parser::Source::Comment::Associator#associate_by_identity
    #
    # source://parser-3.1.2.1/lib/parser/source/comment.rb:59
    def associate_by_identity(ast, comments); end

    # Associate `comments` with `ast` nodes by their location in the
    # source.
    #
    # @api public
    # @param ast [Parser::AST::Node]
    # @param comments [Array<Comment>]
    # @return [Hash<Parser::Source::Map, Array<Comment>>]
    # @see Parser::Source::Comment::Associator#associate_locations
    #
    # source://parser-3.1.2.1/lib/parser/source/comment.rb:46
    def associate_locations(ast, comments); end
  end
end

# source://parser-3.1.2.1/lib/parser/source/comment/associator.rb:45
class Parser::Source::Comment::Associator
  # source://parser-3.1.2.1/lib/parser/source/comment/associator.rb:51
  def initialize(ast, comments); end

  # source://parser-3.1.2.1/lib/parser/source/comment/associator.rb:92
  def associate; end

  # source://parser-3.1.2.1/lib/parser/source/comment/associator.rb:115
  def associate_by_identity; end

  # source://parser-3.1.2.1/lib/parser/source/comment/associator.rb:103
  def associate_locations; end

  # source://parser-3.1.2.1/lib/parser/source/comment/associator.rb:46
  def skip_directives; end

  # source://parser-3.1.2.1/lib/parser/source/comment/associator.rb:46
  def skip_directives=(_arg0); end

  private

  # source://parser-3.1.2.1/lib/parser/source/comment/associator.rb:182
  def advance_comment; end

  # source://parser-3.1.2.1/lib/parser/source/comment/associator.rb:214
  def advance_through_directives; end

  # source://parser-3.1.2.1/lib/parser/source/comment/associator.rb:206
  def associate_and_advance_comment(node); end

  # source://parser-3.1.2.1/lib/parser/source/comment/associator.rb:123
  def children_in_source_order(node); end

  # source://parser-3.1.2.1/lib/parser/source/comment/associator.rb:187
  def current_comment_before?(node); end

  # source://parser-3.1.2.1/lib/parser/source/comment/associator.rb:194
  def current_comment_before_end?(node); end

  # source://parser-3.1.2.1/lib/parser/source/comment/associator.rb:201
  def current_comment_decorates?(node); end

  # source://parser-3.1.2.1/lib/parser/source/comment/associator.rb:135
  def do_associate; end

  # source://parser-3.1.2.1/lib/parser/source/comment/associator.rb:166
  def process_leading_comments(node); end

  # source://parser-3.1.2.1/lib/parser/source/comment/associator.rb:173
  def process_trailing_comments(node); end

  # source://parser-3.1.2.1/lib/parser/source/comment/associator.rb:148
  def visit(node); end
end

# source://parser-3.1.2.1/lib/parser/source/comment/associator.rb:212
Parser::Source::Comment::Associator::MAGIC_COMMENT_RE = T.let(T.unsafe(nil), Regexp)

# source://parser-3.1.2.1/lib/parser/source/comment/associator.rb:122
Parser::Source::Comment::Associator::POSTFIX_TYPES = T.let(T.unsafe(nil), Set)

# {Map} relates AST nodes to the source code they were parsed from.
# More specifically, a {Map} or its subclass contains a set of ranges:
#
#  * `expression`: smallest range which includes all source corresponding
#    to the node and all `expression` ranges of its children.
#  * other ranges (`begin`, `end`, `operator`, ...): node-specific ranges
#    pointing to various interesting tokens corresponding to the node.
#
# Note that the {Map::Heredoc} map is the only one whose `expression` does
# not include other ranges. It only covers the heredoc marker (`<<HERE`),
# not the here document itself.
#
# All ranges except `expression` are defined by {Map} subclasses.
#
# Ranges (except `expression`) can be `nil` if the corresponding token is
# not present in source. For example, a hash may not have opening/closing
# braces, and so would its source map.
#
#     p Parser::CurrentRuby.parse('[1 => 2]').children[0].loc
#     # => <Parser::Source::Map::Collection:0x007f5492b547d8
#     #  @end=nil, @begin=nil,
#     #  @expression=#<Source::Range (string) 1...7>>
#
# The {file:doc/AST_FORMAT.md} document describes how ranges associated to source
# code tokens. For example, the entry
#
#     (array (int 1) (int 2))
#
#     "[1, 2]"
#      ^ begin
#           ^ end
#      ~~~~~~ expression
#
# means that if `node` is an {Parser::AST::Node} `(array (int 1) (int 2))`,
# then `node.loc` responds to `begin`, `end` and `expression`, and
# `node.loc.begin` returns a range pointing at the opening bracket, and so on.
#
# If you want to write code polymorphic by the source map (i.e. accepting
# several subclasses of {Map}), use `respond_to?` instead of `is_a?` to
# check whether the map features the range you need. Concrete {Map}
# subclasses may not be preserved between versions, but their interfaces
# will be kept compatible.
#
# You can visualize the source maps with `ruby-parse -E` command-line tool.
#
# @api public
# @example
#   require 'parser/current'
#
#   p Parser::CurrentRuby.parse('[1, 2]').loc
#   # => #<Parser::Source::Map::Collection:0x007f14b80eccd8
#   #  @end=#<Source::Range (string) 5...6>,
#   #  @begin=#<Source::Range (string) 0...1>,
#   #  @expression=#<Source::Range (string) 0...6>>
#
# source://parser-3.1.2.1/lib/parser/source/map.rb:70
class Parser::Source::Map
  # @api public
  # @param expression [Range]
  # @return [Map] a new instance of Map
  #
  # source://parser-3.1.2.1/lib/parser/source/map.rb:76
  def initialize(expression); end

  # Compares source maps.
  #
  # @api public
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/source/map.rb:140
  def ==(other); end

  # A shortcut for `self.expression.column`.
  #
  # @api public
  # @return [Integer]
  #
  # source://parser-3.1.2.1/lib/parser/source/map.rb:109
  def column; end

  # @api public
  # @return [Range]
  #
  # source://parser-3.1.2.1/lib/parser/source/map.rb:72
  def expression; end

  # A shortcut for `self.expression.line`.
  #
  # @api public
  # @return [Integer]
  #
  # source://parser-3.1.2.1/lib/parser/source/map.rb:99
  def first_line; end

  # A shortcut for `self.expression.last_column`.
  #
  # @api public
  # @return [Integer]
  #
  # source://parser-3.1.2.1/lib/parser/source/map.rb:125
  def last_column; end

  # A shortcut for `self.expression.last_line`.
  #
  # @api public
  # @return [Integer]
  #
  # source://parser-3.1.2.1/lib/parser/source/map.rb:117
  def last_line; end

  # A shortcut for `self.expression.line`.
  #
  # @api public
  # @return [Integer]
  #
  # source://parser-3.1.2.1/lib/parser/source/map.rb:99
  def line; end

  # The node that is described by this map. Nodes and maps have 1:1 correspondence.
  #
  # @api public
  # @return [Parser::AST::Node]
  #
  # source://parser-3.1.2.1/lib/parser/source/map.rb:71
  def node; end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/source/map.rb:89
  def node=(node); end

  # Converts this source map to a hash with keys corresponding to
  # ranges. For example, if called on an instance of {Collection},
  # which adds the `begin` and `end` ranges, the resulting hash
  # will contain keys `:expression`, `:begin` and `:end`.
  #
  # @api public
  # @example
  #   require 'parser/current'
  #
  #   p Parser::CurrentRuby.parse('[1, 2]').loc.to_hash
  #   # => {
  #   #   :begin => #<Source::Range (string) 0...1>,
  #   #   :end => #<Source::Range (string) 5...6>,
  #   #   :expression => #<Source::Range (string) 0...6>
  #   # }
  # @return [Hash<Symbol, Parser::Source::Range>]
  #
  # source://parser-3.1.2.1/lib/parser/source/map.rb:166
  def to_hash; end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/source/map.rb:132
  def with_expression(expression_l); end

  protected

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map.rb:180
  def update_expression(expression_l); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map.rb:176
  def with(&block); end

  private

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/source/map.rb:82
  def initialize_copy(other); end
end

# @api public
#
# source://parser-3.1.2.1/lib/parser/source/map/collection.rb:6
class Parser::Source::Map::Collection < ::Parser::Source::Map
  # @api public
  # @return [Collection] a new instance of Collection
  #
  # source://parser-3.1.2.1/lib/parser/source/map/collection.rb:10
  def initialize(begin_l, end_l, expression_l); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/collection.rb:7
  def begin; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/collection.rb:8
  def end; end
end

# @api public
#
# source://parser-3.1.2.1/lib/parser/source/map/condition.rb:6
class Parser::Source::Map::Condition < ::Parser::Source::Map
  # @api public
  # @return [Condition] a new instance of Condition
  #
  # source://parser-3.1.2.1/lib/parser/source/map/condition.rb:12
  def initialize(keyword_l, begin_l, else_l, end_l, expression_l); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/condition.rb:8
  def begin; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/condition.rb:9
  def else; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/condition.rb:10
  def end; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/condition.rb:7
  def keyword; end
end

# @api public
#
# source://parser-3.1.2.1/lib/parser/source/map/constant.rb:6
class Parser::Source::Map::Constant < ::Parser::Source::Map
  # @api public
  # @return [Constant] a new instance of Constant
  #
  # source://parser-3.1.2.1/lib/parser/source/map/constant.rb:11
  def initialize(double_colon, name, expression); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/constant.rb:7
  def double_colon; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/constant.rb:8
  def name; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/constant.rb:9
  def operator; end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/source/map/constant.rb:20
  def with_operator(operator_l); end

  protected

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/constant.rb:26
  def update_operator(operator_l); end
end

# @api public
#
# source://parser-3.1.2.1/lib/parser/source/map/definition.rb:6
class Parser::Source::Map::Definition < ::Parser::Source::Map
  # @api public
  # @return [Definition] a new instance of Definition
  #
  # source://parser-3.1.2.1/lib/parser/source/map/definition.rb:12
  def initialize(keyword_l, operator_l, name_l, end_l); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/definition.rb:10
  def end; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/definition.rb:7
  def keyword; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/definition.rb:9
  def name; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/definition.rb:8
  def operator; end
end

# @api public
#
# source://parser-3.1.2.1/lib/parser/source/map/for.rb:6
class Parser::Source::Map::For < ::Parser::Source::Map
  # @api public
  # @return [For] a new instance of For
  #
  # source://parser-3.1.2.1/lib/parser/source/map/for.rb:10
  def initialize(keyword_l, in_l, begin_l, end_l, expression_l); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/for.rb:8
  def begin; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/for.rb:8
  def end; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/for.rb:7
  def in; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/for.rb:7
  def keyword; end
end

# @api public
#
# source://parser-3.1.2.1/lib/parser/source/map/heredoc.rb:6
class Parser::Source::Map::Heredoc < ::Parser::Source::Map
  # @api public
  # @return [Heredoc] a new instance of Heredoc
  #
  # source://parser-3.1.2.1/lib/parser/source/map/heredoc.rb:10
  def initialize(begin_l, body_l, end_l); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/heredoc.rb:7
  def heredoc_body; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/heredoc.rb:8
  def heredoc_end; end
end

# @api public
#
# source://parser-3.1.2.1/lib/parser/source/map/index.rb:6
class Parser::Source::Map::Index < ::Parser::Source::Map
  # @api public
  # @return [Index] a new instance of Index
  #
  # source://parser-3.1.2.1/lib/parser/source/map/index.rb:11
  def initialize(begin_l, end_l, expression_l); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/index.rb:7
  def begin; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/index.rb:8
  def end; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/index.rb:9
  def operator; end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/source/map/index.rb:21
  def with_operator(operator_l); end

  protected

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/index.rb:27
  def update_operator(operator_l); end
end

# @api public
#
# source://parser-3.1.2.1/lib/parser/source/map/keyword.rb:6
class Parser::Source::Map::Keyword < ::Parser::Source::Map
  # @api public
  # @return [Keyword] a new instance of Keyword
  #
  # source://parser-3.1.2.1/lib/parser/source/map/keyword.rb:11
  def initialize(keyword_l, begin_l, end_l, expression_l); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/keyword.rb:8
  def begin; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/keyword.rb:9
  def end; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/keyword.rb:7
  def keyword; end
end

# @api public
#
# source://parser-3.1.2.1/lib/parser/source/map/method_definition.rb:6
class Parser::Source::Map::MethodDefinition < ::Parser::Source::Map
  # @api public
  # @return [MethodDefinition] a new instance of MethodDefinition
  #
  # source://parser-3.1.2.1/lib/parser/source/map/method_definition.rb:13
  def initialize(keyword_l, operator_l, name_l, end_l, assignment_l, body_l); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/method_definition.rb:11
  def assignment; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/method_definition.rb:10
  def end; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/method_definition.rb:7
  def keyword; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/method_definition.rb:9
  def name; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/method_definition.rb:8
  def operator; end
end

# @api public
#
# source://parser-3.1.2.1/lib/parser/source/map/objc_kwarg.rb:6
class Parser::Source::Map::ObjcKwarg < ::Parser::Source::Map
  # @api public
  # @return [ObjcKwarg] a new instance of ObjcKwarg
  #
  # source://parser-3.1.2.1/lib/parser/source/map/objc_kwarg.rb:11
  def initialize(keyword_l, operator_l, argument_l, expression_l); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/objc_kwarg.rb:9
  def argument; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/objc_kwarg.rb:7
  def keyword; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/objc_kwarg.rb:8
  def operator; end
end

# @api public
#
# source://parser-3.1.2.1/lib/parser/source/map/operator.rb:6
class Parser::Source::Map::Operator < ::Parser::Source::Map
  # @api public
  # @return [Operator] a new instance of Operator
  #
  # source://parser-3.1.2.1/lib/parser/source/map/operator.rb:9
  def initialize(operator, expression); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/operator.rb:7
  def operator; end
end

# @api public
#
# source://parser-3.1.2.1/lib/parser/source/map/rescue_body.rb:6
class Parser::Source::Map::RescueBody < ::Parser::Source::Map
  # @api public
  # @return [RescueBody] a new instance of RescueBody
  #
  # source://parser-3.1.2.1/lib/parser/source/map/rescue_body.rb:11
  def initialize(keyword_l, assoc_l, begin_l, expression_l); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/rescue_body.rb:8
  def assoc; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/rescue_body.rb:9
  def begin; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/rescue_body.rb:7
  def keyword; end
end

# @api public
#
# source://parser-3.1.2.1/lib/parser/source/map/send.rb:6
class Parser::Source::Map::Send < ::Parser::Source::Map
  # @api public
  # @return [Send] a new instance of Send
  #
  # source://parser-3.1.2.1/lib/parser/source/map/send.rb:13
  def initialize(dot_l, selector_l, begin_l, end_l, expression_l); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/send.rb:10
  def begin; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/send.rb:7
  def dot; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/send.rb:11
  def end; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/send.rb:9
  def operator; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/send.rb:8
  def selector; end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/source/map/send.rb:24
  def with_operator(operator_l); end

  protected

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/send.rb:30
  def update_operator(operator_l); end
end

# @api public
#
# source://parser-3.1.2.1/lib/parser/source/map/ternary.rb:6
class Parser::Source::Map::Ternary < ::Parser::Source::Map
  # @api public
  # @return [Ternary] a new instance of Ternary
  #
  # source://parser-3.1.2.1/lib/parser/source/map/ternary.rb:10
  def initialize(question_l, colon_l, expression_l); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/ternary.rb:8
  def colon; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/ternary.rb:7
  def question; end
end

# @api public
#
# source://parser-3.1.2.1/lib/parser/source/map/variable.rb:6
class Parser::Source::Map::Variable < ::Parser::Source::Map
  # @api public
  # @return [Variable] a new instance of Variable
  #
  # source://parser-3.1.2.1/lib/parser/source/map/variable.rb:10
  def initialize(name_l, expression_l = T.unsafe(nil)); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/variable.rb:7
  def name; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/variable.rb:8
  def operator; end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/source/map/variable.rb:19
  def with_operator(operator_l); end

  protected

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/map/variable.rb:25
  def update_operator(operator_l); end
end

# A range of characters in a particular source buffer.
#
# The range is always exclusive, i.e. a range with `begin_pos` of 3 and
# `end_pos` of 5 will contain the following characters:
#
#     example
#        ^^
#
# @api public
#
# source://parser-3.1.2.1/lib/parser/source/range.rb:26
class Parser::Source::Range
  include ::Comparable

  # @api public
  # @param source_buffer [Buffer]
  # @param begin_pos [Integer]
  # @param end_pos [Integer]
  # @return [Range] a new instance of Range
  #
  # source://parser-3.1.2.1/lib/parser/source/range.rb:37
  def initialize(source_buffer, begin_pos, end_pos); end

  # Compare ranges, first by begin_pos, then by end_pos.
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/range.rb:301
  def <=>(other); end

  # by the given amount(s)
  #
  # @api public
  # @param Endpoint(s) [Hash] to change, any combination of :begin_pos or :end_pos
  # @return [Range] the same range as this range but with the given end point(s) adjusted
  #
  # source://parser-3.1.2.1/lib/parser/source/range.rb:193
  def adjust(begin_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end

  # @api public
  # @return [Range] a zero-length range located just before the beginning
  #   of this range.
  #
  # source://parser-3.1.2.1/lib/parser/source/range.rb:55
  def begin; end

  # @api public
  # @return [Integer] index of the first character in the range
  #
  # source://parser-3.1.2.1/lib/parser/source/range.rb:30
  def begin_pos; end

  # @api public
  # @return [Integer] zero-based column number of the beginning of this range.
  #
  # source://parser-3.1.2.1/lib/parser/source/range.rb:92
  def column; end

  # @api public
  # @raise RangeError
  # @return [::Range] a range of columns spanned by this range.
  #
  # source://parser-3.1.2.1/lib/parser/source/range.rb:114
  def column_range; end

  # Return `other.contains?(self)`
  #
  # Two ranges must be one and only one of ==, disjoint?, contains?, contained? or crossing?
  #
  # @api public
  # @param other [Range]
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/source/range.rb:274
  def contained?(other); end

  # Returns true iff this range contains (strictly) `other`.
  #
  # Two ranges must be one and only one of ==, disjoint?, contains?, contained? or crossing?
  #
  # @api public
  # @param other [Range]
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/source/range.rb:262
  def contains?(other); end

  # Returns true iff both ranges intersect and also have different elements from one another.
  #
  # Two ranges must be one and only one of ==, disjoint?, contains?, contained? or crossing?
  #
  # @api public
  # @param other [Range]
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/source/range.rb:286
  def crossing?(other); end

  # Return `true` iff this range and `other` are disjoint.
  #
  # Two ranges must be one and only one of ==, disjoint?, contains?, contained? or crossing?
  #
  # @api public
  # @param other [Range]
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/source/range.rb:236
  def disjoint?(other); end

  # Checks if a range is empty; if it contains no characters
  #
  # @api public
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/source/range.rb:294
  def empty?; end

  # @api public
  # @return [Range] a zero-length range located just after the end
  #   of this range.
  #
  # source://parser-3.1.2.1/lib/parser/source/range.rb:63
  def end; end

  # @api public
  # @return [Integer] index of the character after the last character in the range
  #
  # source://parser-3.1.2.1/lib/parser/source/range.rb:30
  def end_pos; end

  # @api public
  def eql?(_arg0); end

  # Line number of the beginning of this range. By default, the first line
  # of a buffer is 1; as such, line numbers are most commonly one-based.
  #
  # @api public
  # @return [Integer] line number of the beginning of this range.
  # @see Buffer
  #
  # source://parser-3.1.2.1/lib/parser/source/range.rb:83
  def first_line; end

  # Support for Ranges be used in as Hash indices and in Sets.
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/range.rb:313
  def hash; end

  # @api public
  # @return [String] a human-readable representation of this range.
  #
  # source://parser-3.1.2.1/lib/parser/source/range.rb:320
  def inspect; end

  # @api public
  # @param other [Range]
  # @return [Range] overlapping region of this range and `other`, or `nil`
  #   if they do not overlap
  #
  # source://parser-3.1.2.1/lib/parser/source/range.rb:220
  def intersect(other); end

  # `is?` provides a concise way to compare the source corresponding to this range.
  # For example, `r.source == '(' || r.source == 'begin'` is equivalent to
  # `r.is?('(', 'begin')`.
  #
  # @api public
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/source/range.rb:141
  def is?(*what); end

  # @api public
  # @param other [Range]
  # @return [Range] smallest possible range spanning both this range and `other`.
  #
  # source://parser-3.1.2.1/lib/parser/source/range.rb:209
  def join(other); end

  # @api public
  # @return [Integer] zero-based column number of the end of this range.
  #
  # source://parser-3.1.2.1/lib/parser/source/range.rb:106
  def last_column; end

  # @api public
  # @return [Integer] line number of the end of this range.
  #
  # source://parser-3.1.2.1/lib/parser/source/range.rb:99
  def last_line; end

  # @api public
  # @return [Integer] amount of characters included in this range.
  #
  # source://parser-3.1.2.1/lib/parser/source/range.rb:70
  def length; end

  # Line number of the beginning of this range. By default, the first line
  # of a buffer is 1; as such, line numbers are most commonly one-based.
  #
  # @api public
  # @return [Integer] line number of the beginning of this range.
  # @see Buffer
  #
  # source://parser-3.1.2.1/lib/parser/source/range.rb:83
  def line; end

  # Return `true` iff this range is not disjoint from `other`.
  #
  # @api public
  # @param other [Range]
  # @return [Boolean] `true` if this range and `other` overlap
  #
  # source://parser-3.1.2.1/lib/parser/source/range.rb:250
  def overlaps?(other); end

  # @api public
  # @param new_size [Integer]
  # @return [Range] a range beginning at the same point as this range and length `new_size`.
  #
  # source://parser-3.1.2.1/lib/parser/source/range.rb:201
  def resize(new_size); end

  # @api public
  # @return [Integer] amount of characters included in this range.
  #
  # source://parser-3.1.2.1/lib/parser/source/range.rb:70
  def size; end

  # @api public
  # @return [String] all source code covered by this range.
  #
  # source://parser-3.1.2.1/lib/parser/source/range.rb:132
  def source; end

  # @api public
  # @return [Parser::Source::Buffer]
  #
  # source://parser-3.1.2.1/lib/parser/source/range.rb:29
  def source_buffer; end

  # @api public
  # @return [String] a line of source code containing the beginning of this range.
  #
  # source://parser-3.1.2.1/lib/parser/source/range.rb:125
  def source_line; end

  # @api public
  # @return [Array<Integer>] a set of character indexes contained in this range.
  #
  # source://parser-3.1.2.1/lib/parser/source/range.rb:148
  def to_a; end

  # @api public
  # @return [Range] a Ruby range with the same `begin_pos` and `end_pos`
  #
  # source://parser-3.1.2.1/lib/parser/source/range.rb:155
  def to_range; end

  # Composes a GNU/Clang-style string representation of the beginning of this
  # range.
  #
  # For example, for the following range in file `foo.rb`,
  #
  #     def foo
  #         ^^^
  #
  # `to_s` will return `foo.rb:1:5`.
  # Note that the column index is one-based.
  #
  # @api public
  # @return [String]
  #
  # source://parser-3.1.2.1/lib/parser/source/range.rb:173
  def to_s; end

  # to the given value(s).
  #
  # @api public
  # @param Endpoint(s) [Hash] to change, any combination of :begin_pos or :end_pos
  # @return [Range] the same range as this range but with the given end point(s) changed
  #
  # source://parser-3.1.2.1/lib/parser/source/range.rb:184
  def with(begin_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end
end

# {Rewriter} is deprecated. Use {TreeRewriter} instead.
#
# TreeRewriter has simplified semantics, and customizable policies
# with regards to clobbering. Please read the documentation.
#
# Keep in mind:
# - Rewriter was discarding the `end_pos` of the given range for `insert_before`,
#   and the `begin_pos` for `insert_after`. These are meaningful in TreeRewriter.
# - TreeRewriter's wrap/insert_before/insert_after are multiple by default, while
#   Rewriter would raise clobbering errors if the non '_multi' version was called.
# - The TreeRewriter policy closest to Rewriter's behavior is:
#       different_replacements: :raise,
#       swallowed_insertions: :raise,
#       crossing_deletions: :accept
#
# @api public
# @deprecated Use {TreeRewriter}
#
# source://parser-3.1.2.1/lib/parser/source/rewriter.rb:31
class Parser::Source::Rewriter
  extend ::Parser::Deprecation

  # @api public
  # @deprecated Use {TreeRewriter}
  # @param source_buffer [Source::Buffer]
  # @return [Rewriter] a new instance of Rewriter
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter.rb:39
  def initialize(source_buffer); end

  # @api public
  # @return [Diagnostic::Engine]
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter.rb:33
  def diagnostics; end

  # Inserts new code after the given source range.
  #
  # @api public
  # @deprecated Use {TreeRewriter#insert_after}
  # @param range [Range]
  # @param content [String]
  # @raise [ClobberingError] when clobbering is detected
  # @return [Rewriter] self
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter.rb:131
  def insert_after(range, content); end

  # Inserts new code after the given source range by allowing other
  # insertions at the same position.
  # Note that an insertion with latter invocation comes _after_ earlier
  # insertion at the same position in the rewritten source.
  #
  # @api public
  # @deprecated Use {TreeRewriter#insert_after}
  # @example Inserting ')]'
  #   rewriter.
  #   insert_after_multi(range, ')').
  #   insert_after_multi(range, ']').
  #   process
  # @param range [Range]
  # @param content [String]
  # @raise [ClobberingError] when clobbering is detected
  # @return [Rewriter] self
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter.rb:153
  def insert_after_multi(range, content); end

  # Inserts new code before the given source range.
  #
  # @api public
  # @deprecated Use {TreeRewriter#insert_before}
  # @param range [Range]
  # @param content [String]
  # @raise [ClobberingError] when clobbering is detected
  # @return [Rewriter] self
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter.rb:80
  def insert_before(range, content); end

  # Inserts new code before the given source range by allowing other
  # insertions at the same position.
  # Note that an insertion with latter invocation comes _before_ earlier
  # insertion at the same position in the rewritten source.
  #
  # @api public
  # @deprecated Use {TreeRewriter#insert_before}
  # @example Inserting '[('
  #   rewriter.
  #   insert_before_multi(range, '(').
  #   insert_before_multi(range, '[').
  #   process
  # @param range [Range]
  # @param content [String]
  # @raise [ClobberingError] when clobbering is detected
  # @return [Rewriter] self
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter.rb:117
  def insert_before_multi(range, content); end

  # Applies all scheduled changes to the `source_buffer` and returns
  # modified source as a new string.
  #
  # @api public
  # @deprecated Use {TreeRewriter#process}
  # @return [String]
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter.rb:178
  def process; end

  # Removes the source range.
  #
  # @api public
  # @deprecated Use {TreeRewriter#remove}
  # @param range [Range]
  # @raise [ClobberingError] when clobbering is detected
  # @return [Rewriter] self
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter.rb:67
  def remove(range); end

  # Replaces the code of the source range `range` with `content`.
  #
  # @api public
  # @deprecated Use {TreeRewriter#replace}
  # @param range [Range]
  # @param content [String]
  # @raise [ClobberingError] when clobbering is detected
  # @return [Rewriter] self
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter.rb:167
  def replace(range, content); end

  # @api public
  # @return [Source::Buffer]
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter.rb:32
  def source_buffer; end

  # Provides a protected block where a sequence of multiple rewrite actions
  # are handled atomically. If any of the actions failed by clobbering,
  # all the actions are rolled back.
  #
  # @api public
  # @deprecated Use {TreeRewriter#transaction}
  # @example
  #   begin
  #   rewriter.transaction do
  #   rewriter.insert_before(range_of_something, '(')
  #   rewriter.insert_after(range_of_something, ')')
  #   end
  #   rescue Parser::ClobberingError
  #   end
  # @raise [RuntimeError] when no block is passed
  # @raise [RuntimeError] when already in a transaction
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter.rb:216
  def transaction; end

  # Inserts new code before and after the given source range.
  #
  # @api public
  # @deprecated Use {TreeRewriter#wrap}
  # @param range [Range]
  # @param before [String]
  # @param after [String]
  # @raise [ClobberingError] when clobbering is detected
  # @return [Rewriter] self
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter.rb:94
  def wrap(range, before, after); end

  private

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter.rb:476
  def active_clobber; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter.rb:484
  def active_clobber=(value); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter.rb:480
  def active_insertions; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter.rb:492
  def active_insertions=(value); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter.rb:472
  def active_queue; end

  # @api public
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter.rb:500
  def adjacent?(range1, range2); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter.rb:351
  def adjacent_insertion_mask(range); end

  # @api public
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter.rb:366
  def adjacent_insertions?(range); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter.rb:347
  def adjacent_position_mask(range); end

  # @api public
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter.rb:377
  def adjacent_updates?(range); end

  # Schedule a code update. If it overlaps with another update, check
  # whether they conflict, and raise a clobbering error if they do.
  # (As a special case, zero-length ranges at the same position are
  # considered to "overlap".) Otherwise, merge them.
  #
  # Updates which are adjacent to each other, but do not overlap, are also
  # merged.
  #
  # RULES:
  #
  # - Insertion ("replacing" a zero-length range):
  #   - Two insertions at the same point conflict. This is true even
  #     if the earlier insertion has already been merged with an adjacent
  #     update, and even if they are both inserting the same text.
  #   - An insertion never conflicts with a replace or remove operation
  #     on its right or left side, which does not overlap it (in other
  #     words, which does not update BOTH its right and left sides).
  #   - An insertion always conflicts with a remove operation which spans
  #     both its sides.
  #   - An insertion conflicts with a replace operation which spans both its
  #     sides, unless the replacement text is longer than the replaced text
  #     by the size of the insertion (or more), and the portion of
  #     replacement text immediately after the insertion position is
  #     identical to the inserted text.
  #
  # - Removal operations never conflict with each other.
  #
  # - Replacement operations:
  #   - Take the portion of each replacement text which falls within:
  #     - The other operation's replaced region
  #     - The other operation's replacement text, if it extends past the
  #       end of its own replaced region (in other words, if the replacement
  #       text is longer than the text it replaces)
  #   - If and only if the taken texts are identical for both operations,
  #     they do not conflict.
  #
  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter.rb:280
  def append(action); end

  # @api public
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter.rb:389
  def can_merge?(action, existing); end

  # @api public
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter.rb:355
  def clobbered_insertion?(insertion); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter.rb:343
  def clobbered_position_mask(range); end

  # @api public
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter.rb:468
  def in_transaction?; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter.rb:410
  def merge_actions(action, existing); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter.rb:419
  def merge_actions!(action, existing); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter.rb:425
  def merge_replacements(actions); end

  # @api public
  # @raise [ClobberingError]
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter.rb:450
  def raise_clobber_error(action, existing); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter.rb:335
  def record_insertion(range); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter.rb:339
  def record_replace(range); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter.rb:445
  def replace_actions(old, updated); end

  # @api public
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter.rb:383
  def replace_compatible_with_insertion?(replace, insertion); end
end

# @api private
#
# source://parser-3.1.2.1/lib/parser/source/rewriter/action.rb:9
class Parser::Source::Rewriter::Action
  include ::Comparable

  # @api private
  # @return [Action] a new instance of Action
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter/action.rb:15
  def initialize(range, replacement = T.unsafe(nil), allow_multiple_insertions = T.unsafe(nil), order = T.unsafe(nil)); end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter/action.rb:24
  def <=>(other); end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter/action.rb:12
  def allow_multiple_insertions; end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter/action.rb:12
  def allow_multiple_insertions?; end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter/action.rb:12
  def order; end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter/action.rb:12
  def range; end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter/action.rb:12
  def replacement; end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/source/rewriter/action.rb:30
  def to_s; end
end

# @api public
#
# source://parser-3.1.2.1/lib/parser/source/rewriter.rb:504
Parser::Source::Rewriter::DEPRECATION_WARNING = T.let(T.unsafe(nil), String)

# {TreeRewriter} performs the heavy lifting in the source rewriting process.
# It schedules code updates to be performed in the correct order.
#
# For simple cases, the resulting source will be obvious.
#
# Examples for more complex cases follow. Assume these examples are acting on
# the source `'puts(:hello, :world)`. The methods #wrap, #remove, etc.
# receive a Range as first argument; for clarity, examples below use english
# sentences and a string of raw code instead.
#
# ## Overlapping ranges:
#
# Any two rewriting actions on overlapping ranges will fail and raise
# a `ClobberingError`, unless they are both deletions (covered next).
#
# * wrap ':hello, ' with '(' and ')'
# * wrap ', :world' with '(' and ')'
#  => CloberringError
#
# ## Overlapping deletions:
#
# * remove ':hello, '
# * remove ', :world'
#
# The overlapping ranges are merged and `':hello, :world'` will be removed.
# This policy can be changed. `:crossing_deletions` defaults to `:accept`
# but can be set to `:warn` or `:raise`.
#
# ## Multiple actions at the same end points:
#
# Results will always be independent on the order they were given.
# Exception: rewriting actions done on exactly the same range (covered next).
#
# Example:
# * replace ', ' by ' => '
# * wrap ':hello, :world' with '{' and '}'
# * replace ':world' with ':everybody'
# * wrap ':world' with '[', ']'
#
# The resulting string will be `'puts({:hello => [:everybody]})'`
# and this result is independent on the order the instructions were given in.
#
# Note that if the two "replace" were given as a single replacement of ', :world'
# for ' => :everybody', the result would be a `ClobberingError` because of the wrap
# in square brackets.
#
# ## Multiple wraps on same range:
# * wrap ':hello' with '(' and ')'
# * wrap ':hello' with '[' and ']'
#
# The wraps are combined in order given and results would be `'puts([(:hello)], :world)'`.
#
# ## Multiple replacements on same range:
# * replace ':hello' by ':hi', then
# * replace ':hello' by ':hey'
#
# The replacements are made in the order given, so the latter replacement
# supersedes the former and ':hello' will be replaced by ':hey'.
#
# This policy can be changed. `:different_replacements` defaults to `:accept`
# but can be set to `:warn` or `:raise`.
#
# ## Swallowed insertions:
# wrap 'world' by '__', '__'
# replace ':hello, :world' with ':hi'
#
# A containing replacement will swallow the contained rewriting actions
# and `':hello, :world'` will be replaced by `':hi'`.
#
# This policy can be changed for swallowed insertions. `:swallowed_insertions`
# defaults to `:accept` but can be set to `:warn` or `:raise`
#
# ## Implementation
# The updates are organized in a tree, according to the ranges they act on
# (where children are strictly contained by their parent), hence the name.
#
# @api public
#
# source://parser-3.1.2.1/lib/parser/source/tree_rewriter.rb:91
class Parser::Source::TreeRewriter
  extend ::Parser::Deprecation

  # @api public
  # @param source_buffer [Source::Buffer]
  # @return [TreeRewriter] a new instance of TreeRewriter
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter.rb:98
  def initialize(source_buffer, crossing_deletions: T.unsafe(nil), different_replacements: T.unsafe(nil), swallowed_insertions: T.unsafe(nil)); end

  # Returns a representation of the rewriter as nested insertions (:wrap) and replacements.
  #
  #     rewriter.as_actions # =>[ [:wrap, 1...10, '(', ')'],
  #                               [:wrap, 2...6, '', '!'],  # aka "insert_after"
  #                               [:replace, 2...4, 'foo'],
  #                               [:replace, 5...6, ''],  # aka "removal"
  #                             ],
  #
  # Contrary to `as_replacements`, this representation is sufficient to recreate exactly
  # the rewriter.
  #
  # @api public
  # @return [Array<(Symbol, Range, String{, String})>]
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter.rb:299
  def as_nested_actions; end

  # Returns a representation of the rewriter as an ordered list of replacements.
  #
  #     rewriter.as_replacements # => [ [1...1, '('],
  #                                     [2...4, 'foo'],
  #                                     [5...6, ''],
  #                                     [6...6, '!'],
  #                                     [10...10, ')'],
  #                                   ]
  #
  # This representation is sufficient to recreate the result of `process` but it is
  # not sufficient to recreate completely the rewriter for further merging/actions.
  # See `as_nested_actions`
  #
  # @api public
  # @return [Array<Range, String>] an ordered list of pairs of range & replacement
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter.rb:281
  def as_replacements; end

  # @api public
  # @return [Diagnostic::Engine]
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter.rb:93
  def diagnostics; end

  # Returns true iff no (non trivial) update has been recorded
  #
  # @api public
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter.rb:125
  def empty?; end

  # For special cases where one needs to merge a rewriter attached to a different source_buffer
  # or that needs to be offset. Policies of the receiver are used.
  #
  # @api public
  # @param rewriter [TreeRewriter] from different source_buffer
  # @param offset [Integer]
  # @raise [IndexError] if action ranges (once offset) don't fit the current buffer
  # @return [Rewriter] self
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter.rb:168
  def import!(foreign_rewriter, offset: T.unsafe(nil)); end

  # @api public
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter.rb:329
  def in_transaction?; end

  # Shortcut for `wrap(range, nil, content)`
  #
  # @api public
  # @param range [Range]
  # @param content [String]
  # @raise [ClobberingError] when clobbering is detected
  # @return [Rewriter] self
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter.rb:242
  def insert_after(range, content); end

  # @api private
  # @deprecated Use insert_after or wrap
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter.rb:351
  def insert_after_multi(range, text); end

  # Shortcut for `wrap(range, content, nil)`
  #
  # @api public
  # @param range [Range]
  # @param content [String]
  # @raise [ClobberingError] when clobbering is detected
  # @return [Rewriter] self
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter.rb:230
  def insert_before(range, content); end

  # @api private
  # @deprecated Use insert_after or wrap
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter.rb:342
  def insert_before_multi(range, text); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter.rb:334
  def inspect; end

  # Returns a new rewriter that consists of the updates of the received
  # and the given argument. Policies of the receiver are used.
  #
  # @api public
  # @param with [Rewriter]
  # @raise [ClobberingError] when clobbering is detected
  # @return [Rewriter] merge of receiver and argument
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter.rb:155
  def merge(with); end

  # Merges the updates of argument with the receiver.
  # Policies of the receiver are used.
  # This action is atomic in that it won't change the receiver
  # unless it succeeds.
  #
  # @api public
  # @param with [Rewriter]
  # @raise [ClobberingError] when clobbering is detected
  # @return [Rewriter] self
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter.rb:139
  def merge!(with); end

  # Applies all scheduled changes to the `source_buffer` and returns
  # modified source as a new string.
  #
  # @api public
  # @return [String]
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter.rb:252
  def process; end

  # Shortcut for `replace(range, '')`
  #
  # @api public
  # @param range [Range]
  # @raise [ClobberingError] when clobbering is detected
  # @return [Rewriter] self
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter.rb:217
  def remove(range); end

  # Replaces the code of the source range `range` with `content`.
  #
  # @api public
  # @param range [Range]
  # @param content [String]
  # @raise [ClobberingError] when clobbering is detected
  # @return [Rewriter] self
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter.rb:193
  def replace(range, content); end

  # @api public
  # @return [Source::Buffer]
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter.rb:92
  def source_buffer; end

  # Provides a protected block where a sequence of multiple rewrite actions
  # are handled atomically. If any of the actions failed by clobbering,
  # all the actions are rolled back. Transactions can be nested.
  #
  # @api public
  # @raise [RuntimeError] when no block is passed
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter.rb:310
  def transaction; end

  # Inserts the given strings before and after the given range.
  #
  # @api public
  # @param range [Range]
  # @param insert_before [String, nil]
  # @param insert_after [String, nil]
  # @raise [ClobberingError] when clobbering is detected
  # @return [Rewriter] self
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter.rb:206
  def wrap(range, insert_before, insert_after); end

  protected

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter.rb:365
  def action_root; end

  private

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter.rb:369
  def action_summary; end

  # @api public
  # @raise [ArgumentError]
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter.rb:392
  def check_policy_validity; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter.rb:404
  def check_range_validity(range); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter.rb:397
  def combine(range, attributes); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter.rb:411
  def enforce_policy(event); end

  # @api public
  # @raise [Parser::ClobberingError]
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter.rb:418
  def trigger_policy(event, range: T.unsafe(nil), conflict: T.unsafe(nil), **arguments); end
end

# @api public
#
# source://parser-3.1.2.1/lib/parser/source/tree_rewriter.rb:391
Parser::Source::TreeRewriter::ACTIONS = T.let(T.unsafe(nil), Array)

# Actions are arranged in a tree and get combined so that:
#   children are strictly contained by their parent
#   sibblings all disjoint from one another and ordered
#   only actions with replacement==nil may have children
#
# @api private
#
# source://parser-3.1.2.1/lib/parser/source/tree_rewriter/action.rb:13
class Parser::Source::TreeRewriter::Action
  # @api private
  # @return [Action] a new instance of Action
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter/action.rb:16
  def initialize(range, enforcer, insert_before: T.unsafe(nil), replacement: T.unsafe(nil), insert_after: T.unsafe(nil), children: T.unsafe(nil)); end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter/action.rb:28
  def combine(action); end

  # A root action has its range set to the whole source range, even
  # though it typically do not act on that range.
  # This method returns the action as if it was a child action with
  # its range contracted.
  #
  # @api private
  # @return [Action]
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter/action.rb:67
  def contract; end

  # @api private
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter/action.rb:33
  def empty?; end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter/action.rb:14
  def insert_after; end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter/action.rb:14
  def insert_before; end

  # @api private
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter/action.rb:57
  def insertion?; end

  # No check is done on validity of resulting range.
  #
  # @api private
  # @return [Action] that has been moved to the given source_buffer and with the given offset
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter/action.rb:80
  def moved(source_buffer, offset); end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter/action.rb:49
  def nested_actions; end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter/action.rb:40
  def ordered_replacements; end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter/action.rb:14
  def range; end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter/action.rb:14
  def replacement; end

  protected

  # Returns the children in a hierarchy with respect to `action`:
  #   :sibbling_left, sibbling_right (for those that are disjoint from `action`)
  #   :parent (in case one of our children contains `action`)
  #   :child (in case `action` strictly contains some of our children)
  #   :fusible (in case `action` overlaps some children but they can be fused in one deletion)
  #   or raises a `CloberingError`
  # In case a child has equal range to `action`, it is returned as `:parent`
  # Reminder: an empty range 1...1 is considered disjoint from 1...10
  #
  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter/action.rb:158
  def analyse_hierarchy(action); end

  # Similar to @children.bsearch_index || size
  # except allows for a starting point
  # and `bsearch_index` is only Ruby 2.3+
  #
  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter/action.rb:145
  def bsearch_child_index(from = T.unsafe(nil)); end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter/action.rb:224
  def call_enforcer_for_merge(action); end

  # @api private
  # @param fusible [Array(Action | nil)]
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter/action.rb:204
  def check_fusible(action, *fusible); end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter/action.rb:94
  def children; end

  # Assumes `more_children` all contained within `@range`
  #
  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter/action.rb:129
  def combine_children(more_children); end

  # Assumes range.contains?(action.range) && action.children.empty?
  #
  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter/action.rb:102
  def do_combine(action); end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter/action.rb:135
  def fuse_deletions(action, fusible, other_sibblings); end

  # Assumes action.range == range && action.children.empty?
  #
  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter/action.rb:215
  def merge(action); end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter/action.rb:110
  def place_in_hierarchy(action); end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter/action.rb:232
  def swallow(children); end

  # @api private
  #
  # source://parser-3.1.2.1/lib/parser/source/tree_rewriter/action.rb:96
  def with(range: T.unsafe(nil), enforcer: T.unsafe(nil), children: T.unsafe(nil), insert_before: T.unsafe(nil), replacement: T.unsafe(nil), insert_after: T.unsafe(nil)); end
end

# @api public
#
# source://parser-3.1.2.1/lib/parser/source/tree_rewriter.rb:356
Parser::Source::TreeRewriter::DEPRECATION_WARNING = T.let(T.unsafe(nil), String)

# @api public
#
# source://parser-3.1.2.1/lib/parser/source/tree_rewriter.rb:417
Parser::Source::TreeRewriter::POLICY_TO_LEVEL = T.let(T.unsafe(nil), Hash)

# @api public
#
# source://parser-3.1.2.1/lib/parser/static_environment.rb:5
class Parser::StaticEnvironment
  # @api public
  # @return [StaticEnvironment] a new instance of StaticEnvironment
  #
  # source://parser-3.1.2.1/lib/parser/static_environment.rb:9
  def initialize; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/static_environment.rb:38
  def declare(name); end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/static_environment.rb:56
  def declare_anonymous_blockarg; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/static_environment.rb:48
  def declare_forward_args; end

  # @api public
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/static_environment.rb:44
  def declared?(name); end

  # @api public
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/static_environment.rb:60
  def declared_anonymous_blockarg?; end

  # @api public
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/static_environment.rb:52
  def declared_forward_args?; end

  # @api public
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/static_environment.rb:64
  def empty?; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/static_environment.rb:25
  def extend_dynamic; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/static_environment.rb:18
  def extend_static; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/static_environment.rb:13
  def reset; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/static_environment.rb:32
  def unextend; end
end

# @api public
#
# source://parser-3.1.2.1/lib/parser/static_environment.rb:7
Parser::StaticEnvironment::ANONYMOUS_BLOCKARG = T.let(T.unsafe(nil), Symbol)

# @api public
#
# source://parser-3.1.2.1/lib/parser/static_environment.rb:6
Parser::StaticEnvironment::FORWARD_ARGS = T.let(T.unsafe(nil), Symbol)

# {Parser::SyntaxError} is raised whenever parser detects a syntax error,
# similar to the standard SyntaxError class.
#
# @api public
#
# source://parser-3.1.2.1/lib/parser/syntax_error.rb:13
class Parser::SyntaxError < ::StandardError
  # @api public
  # @return [SyntaxError] a new instance of SyntaxError
  #
  # source://parser-3.1.2.1/lib/parser/syntax_error.rb:16
  def initialize(diagnostic); end

  # @api public
  # @return [Parser::Diagnostic]
  #
  # source://parser-3.1.2.1/lib/parser/syntax_error.rb:14
  def diagnostic; end
end

# {Parser::TreeRewriter} offers a basic API that makes it easy to rewrite
# existing ASTs. It's built on top of {Parser::AST::Processor} and
# {Parser::Source::TreeRewriter}
#
# For example, assume you want to remove `do` tokens from a while statement.
# You can do this as following:
#
#     require 'parser/current'
#
#     class RemoveDo < Parser::TreeRewriter
#       def on_while(node)
#         # Check if the statement starts with "do"
#         if node.location.begin.is?('do')
#           remove(node.location.begin)
#         end
#       end
#     end
#
#     code = <<-EOF
#     while true do
#       puts 'hello'
#     end
#     EOF
#
#     ast           = Parser::CurrentRuby.parse code
#     buffer        = Parser::Source::Buffer.new('(example)', source: code)
#     rewriter      = RemoveDo.new
#
#     # Rewrite the AST, returns a String with the new form.
#     puts rewriter.rewrite(buffer, ast)
#
# This would result in the following Ruby code:
#
#     while true
#       puts 'hello'
#     end
#
# Keep in mind that {Parser::TreeRewriter} does not take care of indentation when
# inserting/replacing code so you'll have to do this yourself.
#
# See also [a blog entry](http://whitequark.org/blog/2013/04/26/lets-play-with-ruby-code/)
# describing rewriters in greater detail.
#
# @api public
#
# source://parser-3.1.2.1/lib/parser/tree_rewriter.rb:61
class Parser::TreeRewriter < ::Parser::AST::Processor
  # Returns `true` if the specified node is an assignment node, returns false
  # otherwise.
  #
  # @api public
  # @param node [Parser::AST::Node]
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/tree_rewriter.rb:79
  def assignment?(node); end

  # Inserts new code after the given source range.
  #
  # @api public
  # @param range [Parser::Source::Range]
  # @param content [String]
  #
  # source://parser-3.1.2.1/lib/parser/tree_rewriter.rb:118
  def insert_after(range, content); end

  # Inserts new code before the given source range.
  #
  # @api public
  # @param range [Parser::Source::Range]
  # @param content [String]
  #
  # source://parser-3.1.2.1/lib/parser/tree_rewriter.rb:108
  def insert_before(range, content); end

  # Removes the source range.
  #
  # @api public
  # @param range [Parser::Source::Range]
  #
  # source://parser-3.1.2.1/lib/parser/tree_rewriter.rb:88
  def remove(range); end

  # Replaces the code of the source range `range` with `content`.
  #
  # @api public
  # @param range [Parser::Source::Range]
  # @param content [String]
  #
  # source://parser-3.1.2.1/lib/parser/tree_rewriter.rb:128
  def replace(range, content); end

  # Rewrites the AST/source buffer and returns a String containing the new
  # version.
  #
  # @api public
  # @param source_buffer [Parser::Source::Buffer]
  # @param ast [Parser::AST::Node]
  # @param crossing_deletions:, [Symbol] different_replacements:, swallowed_insertions:
  #   policy arguments for TreeRewriter (optional)
  # @return [String]
  #
  # source://parser-3.1.2.1/lib/parser/tree_rewriter.rb:62
  def rewrite(source_buffer, ast, **policy); end

  # Wraps the given source range with the given values.
  #
  # @api public
  # @param range [Parser::Source::Range]
  # @param content [String]
  #
  # source://parser-3.1.2.1/lib/parser/tree_rewriter.rb:98
  def wrap(range, before, after); end
end

# @api public
#
# source://parser-3.1.2.1/lib/parser/version.rb:4
Parser::VERSION = T.let(T.unsafe(nil), String)

# @api public
#
# source://parser-3.1.2.1/lib/parser/variables_stack.rb:5
class Parser::VariablesStack
  # @api public
  # @return [VariablesStack] a new instance of VariablesStack
  #
  # source://parser-3.1.2.1/lib/parser/variables_stack.rb:6
  def initialize; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/variables_stack.rb:27
  def declare(name); end

  # @api public
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/variables_stack.rb:31
  def declared?(name); end

  # @api public
  # @return [Boolean]
  #
  # source://parser-3.1.2.1/lib/parser/variables_stack.rb:11
  def empty?; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/variables_stack.rb:19
  def pop; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/variables_stack.rb:15
  def push; end

  # @api public
  #
  # source://parser-3.1.2.1/lib/parser/variables_stack.rb:23
  def reset; end
end
