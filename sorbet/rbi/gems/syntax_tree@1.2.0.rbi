# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `syntax_tree` gem.
# Please instead update this file by running `bin/tapioca gem syntax_tree`.

class PrettyPrint
  def initialize(output = T.unsafe(nil), maxwidth = T.unsafe(nil), newline = T.unsafe(nil), &genspace); end

  def break_parent; end
  def breakable(separator = T.unsafe(nil), width = T.unsafe(nil), indent: T.unsafe(nil), force: T.unsafe(nil)); end
  def buffer; end
  def current_group; end
  def fill_breakable(separator = T.unsafe(nil), width = T.unsafe(nil)); end
  def flush; end
  def genspace; end
  def group(indent = T.unsafe(nil), open_object = T.unsafe(nil), close_object = T.unsafe(nil), open_width = T.unsafe(nil), close_width = T.unsafe(nil)); end
  def groups; end
  def if_break; end
  def indent; end
  def line_suffix(priority: T.unsafe(nil)); end
  def maxwidth; end
  def nest(indent); end
  def newline; end
  def output; end
  def target; end
  def text(object = T.unsafe(nil), width = T.unsafe(nil)); end
  def trim; end
  def with_target(target); end

  private

  def fits?(next_command, rest_commands, remaining); end
  def reset; end

  class << self
    def format(output = T.unsafe(nil), maxwidth = T.unsafe(nil), newline = T.unsafe(nil), genspace = T.unsafe(nil)); end
    def singleline_format(output = T.unsafe(nil), maxwidth = T.unsafe(nil), newline = T.unsafe(nil), genspace = T.unsafe(nil)); end
  end
end

class PrettyPrint::Align
  def initialize(indent:, contents: T.unsafe(nil)); end

  def contents; end
  def indent; end
  def pretty_print(q); end
end

class PrettyPrint::BreakParent
  def pretty_print(q); end
end

class PrettyPrint::Breakable
  def initialize(separator = T.unsafe(nil), width = T.unsafe(nil), force: T.unsafe(nil), indent: T.unsafe(nil)); end

  def force?; end
  def indent?; end
  def pretty_print(q); end
  def separator; end
  def width; end
end

module PrettyPrint::Buffer
  class << self
    def for(output); end
  end
end

class PrettyPrint::Buffer::ArrayBuffer < ::PrettyPrint::Buffer::DefaultBuffer
  def initialize(output = T.unsafe(nil)); end

  def trim!; end
end

class PrettyPrint::Buffer::DefaultBuffer
  def initialize(output = T.unsafe(nil)); end

  def <<(object); end
  def output; end
  def trim!; end
end

class PrettyPrint::Buffer::StringBuffer < ::PrettyPrint::Buffer::DefaultBuffer
  def initialize(output = T.unsafe(nil)); end

  def trim!; end
end

PrettyPrint::DEFAULT_GENSPACE = T.let(T.unsafe(nil), Proc)
PrettyPrint::DEFAULT_NEWLINE = T.let(T.unsafe(nil), String)

class PrettyPrint::Group
  def initialize(depth, contents: T.unsafe(nil)); end

  def break; end
  def break?; end
  def contents; end
  def depth; end
  def pretty_print(q); end
end

class PrettyPrint::IfBreak
  def initialize(break_contents: T.unsafe(nil), flat_contents: T.unsafe(nil)); end

  def break_contents; end
  def flat_contents; end
  def pretty_print(q); end
end

class PrettyPrint::IfBreakBuilder
  def initialize(builder, if_break); end

  def builder; end
  def if_break; end
  def if_flat(&block); end
end

class PrettyPrint::Indent
  def initialize(contents: T.unsafe(nil)); end

  def contents; end
  def pretty_print(q); end
end

class PrettyPrint::IndentLevel
  def initialize(genspace:, value: T.unsafe(nil), length: T.unsafe(nil), queue: T.unsafe(nil), root: T.unsafe(nil)); end

  def align(n); end
  def genspace; end
  def indent(part = T.unsafe(nil)); end
  def length; end
  def queue; end
  def root; end
  def value; end
end

PrettyPrint::IndentLevel::DedentPart = T.let(T.unsafe(nil), Object)
PrettyPrint::IndentLevel::IndentPart = T.let(T.unsafe(nil), Object)

class PrettyPrint::IndentLevel::NumberAlignPart < ::Struct
  def n; end
  def n=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class PrettyPrint::IndentLevel::StringAlignPart < ::Struct
  def n; end
  def n=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class PrettyPrint::LineSuffix
  def initialize(priority: T.unsafe(nil), contents: T.unsafe(nil)); end

  def contents; end
  def pretty_print(q); end
  def priority; end
end

PrettyPrint::LineSuffix::DEFAULT_PRIORITY = T.let(T.unsafe(nil), Integer)
PrettyPrint::MODE_BREAK = T.let(T.unsafe(nil), Integer)
PrettyPrint::MODE_FLAT = T.let(T.unsafe(nil), Integer)

class PrettyPrint::SingleLine
  def initialize(output, maxwidth = T.unsafe(nil), newline = T.unsafe(nil)); end

  def break_parent; end
  def breakable(separator = T.unsafe(nil), width = T.unsafe(nil), indent: T.unsafe(nil), force: T.unsafe(nil)); end
  def fill_breakable(separator = T.unsafe(nil), width = T.unsafe(nil)); end
  def flush; end
  def group(indent = T.unsafe(nil), open_object = T.unsafe(nil), close_object = T.unsafe(nil), open_width = T.unsafe(nil), close_width = T.unsafe(nil)); end
  def if_break; end
  def indent; end
  def line_suffix; end
  def line_suffixes; end
  def nest(indent); end
  def output; end
  def target; end
  def text(object = T.unsafe(nil), width = T.unsafe(nil)); end
  def trim; end
end

class PrettyPrint::SingleLine::IfBreakBuilder
  def if_flat; end
end

class PrettyPrint::Text
  def initialize; end

  def add(object: T.unsafe(nil), width: T.unsafe(nil)); end
  def objects; end
  def pretty_print(q); end
  def width; end
end

class PrettyPrint::Trim
  def pretty_print(q); end
end

class SyntaxTree < ::Ripper
  def initialize(source, *_arg1); end

  def comments; end
  def line_counts; end
  def lines; end
  def source; end
  def tokens; end

  private

  def attach_comments(program, comments); end
  def char_pos; end
  def find_colon2_before(const); end
  def find_next_statement_start(position); end
  def find_token(type, value = T.unsafe(nil), consume: T.unsafe(nil), location: T.unsafe(nil)); end
  def nearest_nodes(node, comment); end
  def on_BEGIN(statements); end
  def on_CHAR(value); end
  def on_END(statements); end
  def on___end__(value); end
  def on_alias(left, right); end
  def on_alias_error(error, *_arg1); end
  def on_aref(collection, index); end
  def on_aref_field(collection, index); end
  def on_arg_paren(arguments); end
  def on_args_add(arguments, argument); end
  def on_args_add_block(arguments, block); end
  def on_args_add_star(arguments, argument); end
  def on_args_forward; end
  def on_args_new; end
  def on_array(contents); end
  def on_aryptn(constant, requireds, rest, posts); end
  def on_assign(target, value); end
  def on_assign_error(error, *_arg1); end
  def on_assoc_new(key, value); end
  def on_assoc_splat(value); end
  def on_backref(value); end
  def on_backtick(value); end
  def on_bare_assoc_hash(assocs); end
  def on_begin(bodystmt); end
  def on_binary(left, operator, right); end
  def on_block_var(params, locals); end
  def on_blockarg(name); end
  def on_bodystmt(statements, rescue_clause, else_clause, ensure_clause); end
  def on_brace_block(block_var, statements); end
  def on_break(arguments); end
  def on_call(receiver, operator, message); end
  def on_case(value, consequent); end
  def on_class(constant, superclass, bodystmt); end
  def on_class_name_error(error, *_arg1); end
  def on_comma(value); end
  def on_command(message, arguments); end
  def on_command_call(receiver, operator, message, arguments); end
  def on_comment(value); end
  def on_const(value); end
  def on_const_path_field(parent, constant); end
  def on_const_path_ref(parent, constant); end
  def on_const_ref(constant); end
  def on_cvar(value); end
  def on_def(name, params, bodystmt); end
  def on_defined(value); end
  def on_defs(target, operator, name, params, bodystmt); end
  def on_do_block(block_var, bodystmt); end
  def on_dot2(left, right); end
  def on_dot3(left, right); end
  def on_dyna_symbol(string_content); end
  def on_else(statements); end
  def on_elsif(predicate, statements, consequent); end
  def on_embdoc(value); end
  def on_embdoc_beg(value); end
  def on_embdoc_end(value); end
  def on_embexpr_beg(value); end
  def on_embexpr_end(value); end
  def on_embvar(value); end
  def on_ensure(statements); end
  def on_excessed_comma(*_arg0); end
  def on_fcall(value); end
  def on_field(parent, operator, name); end
  def on_float(value); end
  def on_fndptn(constant, left, values, right); end
  def on_for(index, collection, statements); end
  def on_gvar(value); end
  def on_hash(assocs); end
  def on_heredoc_beg(value); end
  def on_heredoc_dedent(string, width); end
  def on_heredoc_end(value); end
  def on_hshptn(constant, keywords, keyword_rest); end
  def on_ident(value); end
  def on_if(predicate, statements, consequent); end
  def on_if_mod(predicate, statement); end
  def on_ifop(predicate, truthy, falsy); end
  def on_imaginary(value); end
  def on_in(pattern, statements, consequent); end
  def on_int(value); end
  def on_ivar(value); end
  def on_kw(value); end
  def on_kwrest_param(name); end
  def on_label(value); end
  def on_label_end(value); end
  def on_lambda(params, statements); end
  def on_lbrace(value); end
  def on_lbracket(value); end
  def on_lparen(value); end
  def on_massign(target, value); end
  def on_method_add_arg(call, arguments); end
  def on_method_add_block(call, block); end
  def on_mlhs_add(mlhs, part); end
  def on_mlhs_add_post(left, right); end
  def on_mlhs_add_star(mlhs, part); end
  def on_mlhs_new; end
  def on_mlhs_paren(contents); end
  def on_module(constant, bodystmt); end
  def on_mrhs_add(mrhs, part); end
  def on_mrhs_add_star(mrhs, value); end
  def on_mrhs_new; end
  def on_mrhs_new_from_args(arguments); end
  def on_next(arguments); end
  def on_op(value); end
  def on_opassign(target, operator, value); end
  def on_param_error(error, *_arg1); end
  def on_params(requireds, optionals, rest, posts, keywords, keyword_rest, block); end
  def on_paren(contents); end
  def on_parse_error(error, *_arg1); end
  def on_period(value); end
  def on_program(statements); end
  def on_qsymbols_add(qsymbols, element); end
  def on_qsymbols_beg(value); end
  def on_qsymbols_new; end
  def on_qwords_add(qwords, element); end
  def on_qwords_beg(value); end
  def on_qwords_new; end
  def on_rational(value); end
  def on_rbrace(value); end
  def on_rbracket(value); end
  def on_redo; end
  def on_regexp_add(regexp_content, part); end
  def on_regexp_beg(value); end
  def on_regexp_end(value); end
  def on_regexp_literal(regexp_content, ending); end
  def on_regexp_new; end
  def on_rescue(exceptions, variable, statements, consequent); end
  def on_rescue_mod(statement, value); end
  def on_rest_param(name); end
  def on_retry; end
  def on_return(arguments); end
  def on_return0; end
  def on_rparen(value); end
  def on_sclass(target, bodystmt); end
  def on_stmts_add(statements, statement); end
  def on_stmts_new; end
  def on_string_add(string, part); end
  def on_string_concat(left, right); end
  def on_string_content; end
  def on_string_dvar(variable); end
  def on_string_embexpr(statements); end
  def on_string_literal(string); end
  def on_super(arguments); end
  def on_symbeg(value); end
  def on_symbol(value); end
  def on_symbol_literal(value); end
  def on_symbols_add(symbols, word); end
  def on_symbols_beg(value); end
  def on_symbols_new; end
  def on_tlambda(value); end
  def on_tlambeg(value); end
  def on_top_const_field(constant); end
  def on_top_const_ref(constant); end
  def on_tstring_beg(value); end
  def on_tstring_content(value); end
  def on_tstring_end(value); end
  def on_unary(operator, statement); end
  def on_undef(symbols); end
  def on_unless(predicate, statements, consequent); end
  def on_unless_mod(predicate, statement); end
  def on_until(predicate, statements); end
  def on_until_mod(predicate, statement); end
  def on_var_alias(left, right); end
  def on_var_field(value); end
  def on_var_ref(value); end
  def on_vcall(ident); end
  def on_void_stmt; end
  def on_when(arguments, statements, consequent); end
  def on_while(predicate, statements); end
  def on_while_mod(predicate, statement); end
  def on_word_add(word, part); end
  def on_word_new; end
  def on_words_add(words, word); end
  def on_words_beg(value); end
  def on_words_new; end
  def on_xstring_add(xstring, part); end
  def on_xstring_literal(xstring); end
  def on_xstring_new; end
  def on_yield(arguments); end
  def on_yield0; end
  def on_zsuper; end

  class << self
    def format(source); end
    def parse(source); end
    def read(filepath); end
  end
end

class SyntaxTree::ARef
  def initialize(collection:, index:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def collection; end
  def comments; end
  def format(q); end
  def index; end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::ARefField
  def initialize(collection:, index:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def collection; end
  def comments; end
  def format(q); end
  def index; end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::Alias
  def initialize(left:, right:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def left; end
  def location; end
  def pretty_print(q); end
  def right; end
  def to_json(*opts); end
end

class SyntaxTree::Alias::AliasArgumentFormatter
  def initialize(argument); end

  def argument; end
  def comments; end
  def format(q); end
end

class SyntaxTree::ArgBlock
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::ArgParen
  def initialize(arguments:, location:, comments: T.unsafe(nil)); end

  def arguments; end
  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::ArgStar
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::Args
  def initialize(parts:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def parts; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::ArgsForward
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::ArrayLiteral
  def initialize(lbracket:, contents:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def contents; end
  def format(q); end
  def lbracket; end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end

  private

  def qsymbols?; end
  def qwords?; end
  def var_refs?(q); end
end

class SyntaxTree::ArrayLiteral::QSymbolsFormatter
  def initialize(contents); end

  def contents; end
  def format(q); end
end

class SyntaxTree::ArrayLiteral::QWordsFormatter
  def initialize(contents); end

  def contents; end
  def format(q); end
end

class SyntaxTree::ArrayLiteral::VarRefsFormatter
  def initialize(contents); end

  def contents; end
  def format(q); end
end

class SyntaxTree::AryPtn
  def initialize(constant:, requireds:, rest:, posts:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def constant; end
  def format(q); end
  def location; end
  def posts; end
  def pretty_print(q); end
  def requireds; end
  def rest; end
  def to_json(*opts); end
end

class SyntaxTree::AryPtn::RestFormatter
  def initialize(value); end

  def comments; end
  def format(q); end
  def value; end
end

class SyntaxTree::Assign
  def initialize(target:, value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def target; end
  def to_json(*opts); end
  def value; end

  private

  def skip_indent?; end
end

module SyntaxTree::AssignFormatting
  class << self
    def skip_indent?(value); end
  end
end

class SyntaxTree::Assoc
  def initialize(key:, value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def key; end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end

  private

  def format_contents(q); end
end

class SyntaxTree::AssocSplat
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::BEGINBlock
  def initialize(lbrace:, statements:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def lbrace; end
  def location; end
  def pretty_print(q); end
  def statements; end
  def to_json(*opts); end
end

class SyntaxTree::Backref
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::Backtick
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::BareAssocHash
  def initialize(assocs:, location:, comments: T.unsafe(nil)); end

  def assocs; end
  def child_nodes; end
  def comments; end
  def format(q); end
  def format_key(q, key); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::Begin
  def initialize(bodystmt:, location:, comments: T.unsafe(nil)); end

  def bodystmt; end
  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::Binary
  def initialize(left:, operator:, right:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def left; end
  def location; end
  def operator; end
  def pretty_print(q); end
  def right; end
  def to_json(*opts); end
end

class SyntaxTree::BlockArg
  def initialize(name:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def name; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::BlockFormatter
  def initialize(node, block_open, block_close, statements); end

  def block_close; end
  def block_open; end
  def format(q); end
  def node; end
  def statements; end

  private

  def forced_brace_bounds?(q); end
  def forced_do_end_bounds?(q); end
  def format_break(q, opening, closing); end
  def format_flat(q, opening, closing); end
  def unchangeable_bounds?(q); end
end

class SyntaxTree::BlockFormatter::BlockOpenFormatter
  def initialize(text, node); end

  def comments; end
  def format(q); end
  def node; end
  def text; end
end

class SyntaxTree::BlockVar
  def initialize(params:, locals:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def locals; end
  def location; end
  def params; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::BodyStmt
  def initialize(statements:, rescue_clause:, else_clause:, ensure_clause:, location:, comments: T.unsafe(nil)); end

  def bind(start_char, end_char); end
  def child_nodes; end
  def comments; end
  def else_clause; end
  def empty?; end
  def ensure_clause; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def rescue_clause; end
  def statements; end
  def to_json(*opts); end
end

class SyntaxTree::BraceBlock
  def initialize(lbrace:, block_var:, statements:, location:, comments: T.unsafe(nil)); end

  def block_var; end
  def child_nodes; end
  def comments; end
  def format(q); end
  def lbrace; end
  def location; end
  def pretty_print(q); end
  def statements; end
  def to_json(*opts); end
end

class SyntaxTree::Break
  def initialize(arguments:, location:, comments: T.unsafe(nil)); end

  def arguments; end
  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::CHAR
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::CVar
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::Call
  def initialize(receiver:, operator:, message:, arguments:, location:, comments: T.unsafe(nil)); end

  def arguments; end
  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def message; end
  def operator; end
  def pretty_print(q); end
  def receiver; end
  def to_json(*opts); end
end

class SyntaxTree::CallOperatorFormatter
  def initialize(operator); end

  def comments; end
  def format(q); end
  def operator; end
end

class SyntaxTree::Case
  def initialize(keyword:, value:, consequent:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def consequent; end
  def format(q); end
  def keyword; end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::ClassDeclaration
  def initialize(constant:, superclass:, bodystmt:, location:, comments: T.unsafe(nil)); end

  def bodystmt; end
  def child_nodes; end
  def comments; end
  def constant; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def superclass; end
  def to_json(*opts); end
end

class SyntaxTree::Comma
  def initialize(value:, location:); end

  def location; end
  def value; end
end

class SyntaxTree::Command
  def initialize(message:, arguments:, location:, comments: T.unsafe(nil)); end

  def arguments; end
  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def message; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::CommandCall
  def initialize(receiver:, operator:, message:, arguments:, location:, comments: T.unsafe(nil)); end

  def arguments; end
  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def message; end
  def operator; end
  def pretty_print(q); end
  def receiver; end
  def to_json(*opts); end

  private

  def argument_alignment(q, doc); end
  def doc_width(parent); end
end

class SyntaxTree::Comment
  def initialize(value:, inline:, location:); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def ignore?; end
  def inline; end
  def inline?; end
  def leading!; end
  def leading?; end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def trailing!; end
  def trailing?; end
  def value; end
end

class SyntaxTree::Comment::List
  def initialize(comments); end

  def comments; end
  def pretty_print(q); end
end

class SyntaxTree::ConditionalFormatter
  def initialize(keyword, node); end

  def format(q); end
  def keyword; end
  def node; end

  private

  def format_break(q, force:); end
end

class SyntaxTree::ConditionalModFormatter
  def initialize(keyword, node); end

  def format(q); end
  def keyword; end
  def node; end

  private

  def format_break(q); end
  def format_flat(q); end
end

class SyntaxTree::Const
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::ConstPathField
  def initialize(parent:, constant:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def constant; end
  def format(q); end
  def location; end
  def parent; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::ConstPathRef
  def initialize(parent:, constant:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def constant; end
  def format(q); end
  def location; end
  def parent; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::ConstRef
  def initialize(constant:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def constant; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
end

module SyntaxTree::ContainsAssignment
  class << self
    def call(parent); end
  end
end

class SyntaxTree::Def
  def initialize(name:, params:, bodystmt:, location:, comments: T.unsafe(nil)); end

  def bodystmt; end
  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def name; end
  def params; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::DefEndless
  def initialize(target:, operator:, name:, paren:, statement:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def name; end
  def operator; end
  def paren; end
  def pretty_print(q); end
  def statement; end
  def target; end
  def to_json(*opts); end
end

class SyntaxTree::Defined
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::Defs
  def initialize(target:, operator:, name:, params:, bodystmt:, location:, comments: T.unsafe(nil)); end

  def bodystmt; end
  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def name; end
  def operator; end
  def params; end
  def pretty_print(q); end
  def target; end
  def to_json(*opts); end
end

class SyntaxTree::DoBlock
  def initialize(keyword:, block_var:, bodystmt:, location:, comments: T.unsafe(nil)); end

  def block_var; end
  def bodystmt; end
  def child_nodes; end
  def comments; end
  def format(q); end
  def keyword; end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::Dot2
  def initialize(left:, right:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def left; end
  def location; end
  def pretty_print(q); end
  def right; end
  def to_json(*opts); end
end

class SyntaxTree::Dot3
  def initialize(left:, right:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def left; end
  def location; end
  def pretty_print(q); end
  def right; end
  def to_json(*opts); end
end

class SyntaxTree::DotFormatter
  def initialize(operator, node); end

  def format(q); end
  def node; end
  def operator; end
end

class SyntaxTree::DynaSymbol
  def initialize(parts:, quote:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def parts; end
  def pretty_print(q); end
  def quote; end
  def to_json(*opts); end

  private

  def quotes(q); end
end

class SyntaxTree::ENDBlock
  def initialize(lbrace:, statements:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def lbrace; end
  def location; end
  def pretty_print(q); end
  def statements; end
  def to_json(*opts); end
end

class SyntaxTree::Else
  def initialize(statements:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def statements; end
  def to_json(*opts); end
end

class SyntaxTree::Elsif
  def initialize(predicate:, statements:, consequent:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def consequent; end
  def format(q); end
  def location; end
  def predicate; end
  def pretty_print(q); end
  def statements; end
  def to_json(*opts); end
end

class SyntaxTree::EmbDoc
  def initialize(value:, location:); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def ignore?; end
  def inline?; end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::EmbExprBeg
  def initialize(value:, location:); end

  def location; end
  def value; end
end

class SyntaxTree::EmbExprEnd
  def initialize(value:, location:); end

  def location; end
  def value; end
end

class SyntaxTree::EmbVar
  def initialize(value:, location:); end

  def location; end
  def value; end
end

class SyntaxTree::EndContent
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::Ensure
  def initialize(keyword:, statements:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def keyword; end
  def location; end
  def pretty_print(q); end
  def statements; end
  def to_json(*opts); end
end

class SyntaxTree::ExcessedComma
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::FCall
  def initialize(value:, arguments:, location:, comments: T.unsafe(nil)); end

  def arguments; end
  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::Field
  def initialize(parent:, operator:, name:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def name; end
  def operator; end
  def parent; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::FloatLiteral
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::FlowControlFormatter
  def initialize(keyword, node); end

  def format(q); end
  def keyword; end
  def node; end

  private

  def format_arguments(q, opening, closing); end
end

class SyntaxTree::FndPtn
  def initialize(constant:, left:, values:, right:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def constant; end
  def format(q); end
  def left; end
  def location; end
  def pretty_print(q); end
  def right; end
  def to_json(*opts); end
  def values; end
end

class SyntaxTree::For
  def initialize(index:, collection:, statements:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def collection; end
  def comments; end
  def format(q); end
  def index; end
  def location; end
  def pretty_print(q); end
  def statements; end
  def to_json(*opts); end
end

class SyntaxTree::Formatter < ::PP
  def initialize(source, *_arg1, &_arg2); end

  def format(node, stackable: T.unsafe(nil)); end
  def format_each(nodes); end
  def parent; end
  def parents; end
  def quote; end
  def source; end
  def stack; end
end

SyntaxTree::Formatter::COMMENT_PRIORITY = T.let(T.unsafe(nil), Integer)
SyntaxTree::Formatter::HEREDOC_PRIORITY = T.let(T.unsafe(nil), Integer)

class SyntaxTree::GVar
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

module SyntaxTree::HashKeyFormatter
  class << self
    def for(container); end
  end
end

class SyntaxTree::HashKeyFormatter::Labels
  def format_key(q, key); end
end

class SyntaxTree::HashKeyFormatter::Rockets
  def format_key(q, key); end
end

class SyntaxTree::HashLiteral
  def initialize(lbrace:, assocs:, location:, comments: T.unsafe(nil)); end

  def assocs; end
  def child_nodes; end
  def comments; end
  def format(q); end
  def format_key(q, key); end
  def lbrace; end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end

  private

  def format_contents(q); end
end

class SyntaxTree::Heredoc
  def initialize(beginning:, location:, ending: T.unsafe(nil), parts: T.unsafe(nil), comments: T.unsafe(nil)); end

  def beginning; end
  def child_nodes; end
  def comments; end
  def ending; end
  def format(q); end
  def location; end
  def parts; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::HeredocBeg
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::HshPtn
  def initialize(constant:, keywords:, keyword_rest:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def constant; end
  def format(q); end
  def keyword_rest; end
  def keywords; end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::HshPtn::KeywordFormatter
  def initialize(key, value); end

  def comments; end
  def format(q); end
  def key; end
  def value; end
end

class SyntaxTree::HshPtn::KeywordRestFormatter
  def initialize(keyword_rest); end

  def comments; end
  def format(q); end
  def keyword_rest; end
end

class SyntaxTree::IVar
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::Ident
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::If
  def initialize(predicate:, statements:, consequent:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def consequent; end
  def format(q); end
  def location; end
  def predicate; end
  def pretty_print(q); end
  def statements; end
  def to_json(*opts); end
end

class SyntaxTree::IfMod
  def initialize(statement:, predicate:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def predicate; end
  def pretty_print(q); end
  def statement; end
  def to_json(*opts); end
end

class SyntaxTree::IfOp
  def initialize(predicate:, truthy:, falsy:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def falsy; end
  def format(q); end
  def location; end
  def predicate; end
  def pretty_print(q); end
  def to_json(*opts); end
  def truthy; end

  private

  def format_break(q); end
  def format_flat(q); end
end

class SyntaxTree::Imaginary
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::In
  def initialize(pattern:, statements:, consequent:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def consequent; end
  def format(q); end
  def location; end
  def pattern; end
  def pretty_print(q); end
  def statements; end
  def to_json(*opts); end
end

class SyntaxTree::Int
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::Kw
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::KwRestParam
  def initialize(name:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def name; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::LBrace
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::LBracket
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::LParen
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::Label
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::LabelEnd
  def initialize(value:, location:); end

  def location; end
  def value; end
end

class SyntaxTree::Lambda
  def initialize(params:, statements:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def params; end
  def pretty_print(q); end
  def statements; end
  def to_json(*opts); end
end

class SyntaxTree::Location
  def initialize(start_line:, start_char:, end_line:, end_char:); end

  def ==(other); end
  def end_char; end
  def end_line; end
  def start_char; end
  def start_line; end
  def to(other); end
  def to_json(*opts); end

  class << self
    def fixed(line:, char:); end
    def token(line:, char:, size:); end
  end
end

class SyntaxTree::LoopFormatter
  def initialize(keyword, node, statements); end

  def format(q); end
  def keyword; end
  def node; end
  def statements; end

  private

  def format_break(q); end
end

class SyntaxTree::MAssign
  def initialize(target:, value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def target; end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::MLHS
  def initialize(parts:, location:, comma: T.unsafe(nil), comments: T.unsafe(nil)); end

  def child_nodes; end
  def comma; end
  def comma=(_arg0); end
  def comments; end
  def format(q); end
  def location; end
  def parts; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::MLHSParen
  def initialize(contents:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def contents; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::MRHS
  def initialize(parts:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def parts; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::MethodAddBlock
  def initialize(call:, block:, location:, comments: T.unsafe(nil)); end

  def block; end
  def call; end
  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::ModuleDeclaration
  def initialize(constant:, bodystmt:, location:, comments: T.unsafe(nil)); end

  def bodystmt; end
  def child_nodes; end
  def comments; end
  def constant; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::MultiByteString
  def initialize(start, line); end

  def [](byteindex); end
  def indices; end
  def start; end
end

class SyntaxTree::Next
  def initialize(arguments:, location:, comments: T.unsafe(nil)); end

  def arguments; end
  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::Not
  def initialize(statement:, parentheses:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def parentheses; end
  def pretty_print(q); end
  def statement; end
  def to_json(*opts); end
end

class SyntaxTree::Op
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::OpAssign
  def initialize(target:, operator:, value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def operator; end
  def pretty_print(q); end
  def target; end
  def to_json(*opts); end
  def value; end
end

SyntaxTree::PATTERNS = T.let(T.unsafe(nil), Array)

class SyntaxTree::Params
  def initialize(location:, requireds: T.unsafe(nil), optionals: T.unsafe(nil), rest: T.unsafe(nil), posts: T.unsafe(nil), keywords: T.unsafe(nil), keyword_rest: T.unsafe(nil), block: T.unsafe(nil), comments: T.unsafe(nil)); end

  def block; end
  def child_nodes; end
  def comments; end
  def empty?; end
  def format(q); end
  def keyword_rest; end
  def keywords; end
  def location; end
  def optionals; end
  def posts; end
  def pretty_print(q); end
  def requireds; end
  def rest; end
  def to_json(*opts); end
end

class SyntaxTree::Params::KeywordFormatter
  def initialize(name, value); end

  def comments; end
  def format(q); end
  def name; end
  def value; end
end

class SyntaxTree::Params::KeywordRestFormatter
  def initialize(value); end

  def comments; end
  def format(q); end
  def value; end
end

class SyntaxTree::Params::OptionalFormatter
  def initialize(name, value); end

  def comments; end
  def format(q); end
  def name; end
  def value; end
end

class SyntaxTree::Paren
  def initialize(lparen:, contents:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def contents; end
  def format(q); end
  def location; end
  def lparen; end
  def pretty_print(q); end
  def to_json(*opts); end
end

module SyntaxTree::Parentheses
  class << self
    def break(q); end
    def flat(q); end
  end
end

SyntaxTree::Parentheses::NODES = T.let(T.unsafe(nil), Array)

class SyntaxTree::ParseError < ::StandardError
  def initialize(error, lineno, column); end

  def column; end
  def lineno; end
end

class SyntaxTree::Period
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::PinnedBegin
  def initialize(statement:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def statement; end
  def to_json(*opts); end
end

class SyntaxTree::PinnedVarRef
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::Program
  def initialize(statements:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def statements; end
  def to_json(*opts); end
end

class SyntaxTree::QSymbols
  def initialize(beginning:, elements:, location:, comments: T.unsafe(nil)); end

  def beginning; end
  def child_nodes; end
  def comments; end
  def elements; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::QSymbolsBeg
  def initialize(value:, location:); end

  def location; end
  def value; end
end

class SyntaxTree::QWords
  def initialize(beginning:, elements:, location:, comments: T.unsafe(nil)); end

  def beginning; end
  def child_nodes; end
  def comments; end
  def elements; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::QWordsBeg
  def initialize(value:, location:); end

  def location; end
  def value; end
end

module SyntaxTree::Quotes
  class << self
    def locked?(node); end
    def matching(quote); end
    def normalize(content, enclosing); end
  end
end

SyntaxTree::Quotes::PAIRS = T.let(T.unsafe(nil), Hash)

class SyntaxTree::RAssign
  def initialize(value:, operator:, pattern:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def operator; end
  def pattern; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::RBrace
  def initialize(value:, location:); end

  def location; end
  def value; end
end

class SyntaxTree::RBracket
  def initialize(value:, location:); end

  def location; end
  def value; end
end

class SyntaxTree::RParen
  def initialize(value:, location:); end

  def location; end
  def value; end
end

class SyntaxTree::RationalLiteral
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::Redo
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::RegexpBeg
  def initialize(value:, location:); end

  def location; end
  def value; end
end

class SyntaxTree::RegexpContent
  def initialize(beginning:, parts:, location:); end

  def beginning; end
  def location; end
  def parts; end
end

class SyntaxTree::RegexpEnd
  def initialize(value:, location:); end

  def location; end
  def value; end
end

class SyntaxTree::RegexpLiteral
  def initialize(beginning:, ending:, parts:, location:, comments: T.unsafe(nil)); end

  def beginning; end
  def child_nodes; end
  def comments; end
  def ending; end
  def format(q); end
  def location; end
  def parts; end
  def pretty_print(q); end
  def to_json(*opts); end

  private

  def ambiguous?(q); end
  def include?(pattern); end
end

module SyntaxTree::RemoveBreaks
  class << self
    def call(doc); end

    private

    def remove_breaks(doc); end
  end
end

class SyntaxTree::Rescue
  def initialize(exception:, statements:, consequent:, location:, comments: T.unsafe(nil)); end

  def bind_end(end_char); end
  def child_nodes; end
  def comments; end
  def consequent; end
  def exception; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def statements; end
  def to_json(*opts); end
end

class SyntaxTree::RescueEx
  def initialize(exceptions:, variable:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def exceptions; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def variable; end
end

class SyntaxTree::RescueMod
  def initialize(statement:, value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def statement; end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::RestParam
  def initialize(name:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def name; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::Retry
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::Return
  def initialize(arguments:, location:, comments: T.unsafe(nil)); end

  def arguments; end
  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::Return0
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::SClass
  def initialize(target:, bodystmt:, location:, comments: T.unsafe(nil)); end

  def bodystmt; end
  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def target; end
  def to_json(*opts); end
end

class SyntaxTree::SingleByteString
  def initialize(start); end

  def [](byteindex); end
  def start; end
end

class SyntaxTree::Statements
  def initialize(parser, body:, location:, comments: T.unsafe(nil)); end

  def bind(start_char, end_char); end
  def bind_end(end_char); end
  def body; end
  def child_nodes; end
  def comments; end
  def empty?; end
  def format(q); end
  def location; end
  def parser; end
  def pretty_print(q); end
  def to_json(*opts); end

  private

  def attach_comments(start_char, end_char); end
end

class SyntaxTree::StringConcat
  def initialize(left:, right:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def left; end
  def location; end
  def pretty_print(q); end
  def right; end
  def to_json(*opts); end
end

class SyntaxTree::StringContent
  def initialize(parts:, location:); end

  def location; end
  def parts; end
end

class SyntaxTree::StringDVar
  def initialize(variable:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def variable; end
end

class SyntaxTree::StringEmbExpr
  def initialize(statements:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def statements; end
  def to_json(*opts); end
end

class SyntaxTree::StringLiteral
  def initialize(parts:, quote:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def parts; end
  def pretty_print(q); end
  def quote; end
  def to_json(*opts); end
end

class SyntaxTree::Super
  def initialize(arguments:, location:, comments: T.unsafe(nil)); end

  def arguments; end
  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::SymBeg
  def initialize(value:, location:); end

  def location; end
  def value; end
end

class SyntaxTree::SymbolContent
  def initialize(value:, location:); end

  def location; end
  def value; end
end

class SyntaxTree::SymbolLiteral
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::Symbols
  def initialize(beginning:, elements:, location:, comments: T.unsafe(nil)); end

  def beginning; end
  def child_nodes; end
  def comments; end
  def elements; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::SymbolsBeg
  def initialize(value:, location:); end

  def location; end
  def value; end
end

class SyntaxTree::TLamBeg
  def initialize(value:, location:); end

  def location; end
  def value; end
end

class SyntaxTree::TLambda
  def initialize(value:, location:); end

  def location; end
  def value; end
end

class SyntaxTree::TStringBeg
  def initialize(value:, location:); end

  def location; end
  def value; end
end

class SyntaxTree::TStringContent
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def match?(pattern); end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::TStringEnd
  def initialize(value:, location:); end

  def location; end
  def value; end
end

class SyntaxTree::TopConstField
  def initialize(constant:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def constant; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::TopConstRef
  def initialize(constant:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def constant; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::Unary
  def initialize(operator:, statement:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def operator; end
  def pretty_print(q); end
  def statement; end
  def to_json(*opts); end
end

class SyntaxTree::Undef
  def initialize(symbols:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def symbols; end
  def to_json(*opts); end
end

class SyntaxTree::Undef::UndefArgumentFormatter
  def initialize(node); end

  def comments; end
  def format(q); end
  def node; end
end

class SyntaxTree::Unless
  def initialize(predicate:, statements:, consequent:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def consequent; end
  def format(q); end
  def location; end
  def predicate; end
  def pretty_print(q); end
  def statements; end
  def to_json(*opts); end
end

class SyntaxTree::UnlessMod
  def initialize(statement:, predicate:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def predicate; end
  def pretty_print(q); end
  def statement; end
  def to_json(*opts); end
end

class SyntaxTree::Until
  def initialize(predicate:, statements:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def predicate; end
  def pretty_print(q); end
  def statements; end
  def to_json(*opts); end
end

class SyntaxTree::UntilMod
  def initialize(statement:, predicate:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def predicate; end
  def pretty_print(q); end
  def statement; end
  def to_json(*opts); end
end

class SyntaxTree::VCall
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

SyntaxTree::VERSION = T.let(T.unsafe(nil), String)

class SyntaxTree::VarAlias
  def initialize(left:, right:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def left; end
  def location; end
  def pretty_print(q); end
  def right; end
  def to_json(*opts); end
end

class SyntaxTree::VarField
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::VarRef
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::VoidStmt
  def initialize(location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::When
  def initialize(arguments:, statements:, consequent:, location:, comments: T.unsafe(nil)); end

  def arguments; end
  def child_nodes; end
  def comments; end
  def consequent; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def statements; end
  def to_json(*opts); end
end

class SyntaxTree::While
  def initialize(predicate:, statements:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def predicate; end
  def pretty_print(q); end
  def statements; end
  def to_json(*opts); end
end

class SyntaxTree::WhileMod
  def initialize(statement:, predicate:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def predicate; end
  def pretty_print(q); end
  def statement; end
  def to_json(*opts); end
end

class SyntaxTree::Word
  def initialize(parts:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def match?(pattern); end
  def parts; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::Words
  def initialize(beginning:, elements:, location:, comments: T.unsafe(nil)); end

  def beginning; end
  def child_nodes; end
  def comments; end
  def elements; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::WordsBeg
  def initialize(value:, location:); end

  def location; end
  def value; end
end

class SyntaxTree::XString
  def initialize(parts:, location:); end

  def location; end
  def parts; end
end

class SyntaxTree::XStringLiteral
  def initialize(parts:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def parts; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::Yield
  def initialize(arguments:, location:, comments: T.unsafe(nil)); end

  def arguments; end
  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
end

class SyntaxTree::Yield0
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end

class SyntaxTree::ZSuper
  def initialize(value:, location:, comments: T.unsafe(nil)); end

  def child_nodes; end
  def comments; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def to_json(*opts); end
  def value; end
end
