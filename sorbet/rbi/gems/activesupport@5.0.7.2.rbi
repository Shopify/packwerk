# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `activesupport` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: false

::MissingSourceFile = T.let(T.unsafe(nil), ActiveSupport::Deprecation::DeprecatedConstantProxy)

module ActiveSupport
  extend ::ActiveSupport::LazyLoadHooks
  extend ::ActiveSupport::Autoload

  def parse_json_times; end
  def parse_json_times=(obj); end
  def test_order; end
  def test_order=(obj); end

  class << self
    def eager_load!; end
    def escape_html_entities_in_json(*args, &block); end
    def escape_html_entities_in_json=(arg); end
    def gem_version; end
    def halt_callback_chains_on_return_false; end
    def halt_callback_chains_on_return_false=(value); end
    def json_encoder(*args, &block); end
    def json_encoder=(arg); end
    def parse_json_times; end
    def parse_json_times=(obj); end
    def test_order; end
    def test_order=(obj); end
    def time_precision(*args, &block); end
    def time_precision=(arg); end
    def to_time_preserves_timezone; end
    def to_time_preserves_timezone=(value); end
    def use_standard_json_time_format(*args, &block); end
    def use_standard_json_time_format=(arg); end
    def version; end
  end
end

class ActiveSupport::ArrayInquirer < ::Array
  def any?(*candidates, &block); end

  private

  def method_missing(name, *args); end
  def respond_to_missing?(name, include_private = T.unsafe(nil)); end
end

module ActiveSupport::Autoload
  def autoload(const_name, path = T.unsafe(nil)); end
  def autoload_at(path); end
  def autoload_under(path); end
  def autoloads; end
  def eager_autoload; end
  def eager_load!; end

  class << self
    def extended(base); end
  end
end

class ActiveSupport::BacktraceCleaner
  def initialize; end

  def add_filter(&block); end
  def add_silencer(&block); end
  def clean(backtrace, kind = T.unsafe(nil)); end
  def filter(backtrace, kind = T.unsafe(nil)); end
  def remove_filters!; end
  def remove_silencers!; end

  private

  def filter_backtrace(backtrace); end
  def noise(backtrace); end
  def silence(backtrace); end
end

module ActiveSupport::Benchmarkable
  def benchmark(message = T.unsafe(nil), options = T.unsafe(nil)); end
end

module ActiveSupport::BigDecimalWithDefaultFormat
  def to_s(format = T.unsafe(nil)); end
end

ActiveSupport::BigDecimalWithDefaultFormat::DEFAULT_STRING_FORMAT = T.let(T.unsafe(nil), String)

module ActiveSupport::Cache
  class << self
    def expand_cache_key(key, namespace = T.unsafe(nil)); end
    def lookup_store(*store_option); end

    private

    def retrieve_cache_key(key); end
    def retrieve_store_class(store); end
  end
end

class ActiveSupport::Cache::Entry
  def initialize(value, options = T.unsafe(nil)); end

  def dup_value!; end
  def expired?; end
  def expires_at; end
  def expires_at=(value); end
  def size; end
  def value; end

  private

  def compress(value); end
  def compressed?; end
  def should_compress?(value, options); end
  def uncompress(value); end
end

ActiveSupport::Cache::Entry::DEFAULT_COMPRESS_LIMIT = T.let(T.unsafe(nil), Integer)

class ActiveSupport::Cache::FileStore < ::ActiveSupport::Cache::Store
  include ::ActiveSupport::Cache::Strategy::LocalCache

  def initialize(cache_path, options = T.unsafe(nil)); end

  def cache_path; end
  def delete_matched(matcher, options = T.unsafe(nil)); end

  private

  def delete_empty_directories(dir); end
  def ensure_cache_path(path); end
  def exclude_from(source, excludes); end
  def file_path_key(path); end
  def key_file_path(key); end
  def lock_file(file_name, &block); end
  def modify_value(name, amount, options); end
  def normalize_key(key, options); end
  def search_dir(dir, &callback); end
end

ActiveSupport::Cache::FileStore::DIR_FORMATTER = T.let(T.unsafe(nil), String)
ActiveSupport::Cache::FileStore::EXCLUDED_DIRS = T.let(T.unsafe(nil), Array)
ActiveSupport::Cache::FileStore::FILENAME_MAX_SIZE = T.let(T.unsafe(nil), Integer)
ActiveSupport::Cache::FileStore::FILEPATH_MAX_SIZE = T.let(T.unsafe(nil), Integer)
ActiveSupport::Cache::FileStore::GITKEEP_FILES = T.let(T.unsafe(nil), Array)

class ActiveSupport::Cache::MemoryStore < ::ActiveSupport::Cache::Store
  def initialize(options = T.unsafe(nil)); end

  def cleanup(options = T.unsafe(nil)); end
  def clear(options = T.unsafe(nil)); end
  def decrement(name, amount = T.unsafe(nil), options = T.unsafe(nil)); end
  def delete_matched(matcher, options = T.unsafe(nil)); end
  def increment(name, amount = T.unsafe(nil), options = T.unsafe(nil)); end
  def inspect; end
  def prune(target_size, max_time = T.unsafe(nil)); end
  def pruning?; end
  def synchronize(&block); end

  protected

  def cached_size(key, entry); end
  def delete_entry(key, options); end
  def read_entry(key, options); end
  def write_entry(key, entry, options); end

  private

  def modify_value(name, amount, options); end
end

ActiveSupport::Cache::MemoryStore::PER_ENTRY_OVERHEAD = T.let(T.unsafe(nil), Integer)

class ActiveSupport::Cache::NullStore < ::ActiveSupport::Cache::Store
  include ::ActiveSupport::Cache::Strategy::LocalCache

  def delete_matched(matcher, options = T.unsafe(nil)); end
end

class ActiveSupport::Cache::Store
  def initialize(options = T.unsafe(nil)); end

  def cleanup(options = T.unsafe(nil)); end
  def clear(options = T.unsafe(nil)); end
  def decrement(name, amount = T.unsafe(nil), options = T.unsafe(nil)); end
  def delete(name, options = T.unsafe(nil)); end
  def delete_matched(matcher, options = T.unsafe(nil)); end
  def exist?(name, options = T.unsafe(nil)); end
  def fetch(name, options = T.unsafe(nil)); end
  def fetch_multi(*names); end
  def increment(name, amount = T.unsafe(nil), options = T.unsafe(nil)); end
  def logger; end
  def logger=(obj); end
  def mute; end
  def options; end
  def read(name, options = T.unsafe(nil)); end
  def read_multi(*names); end
  def silence; end
  def silence!; end
  def silence?; end
  def write(name, value, options = T.unsafe(nil)); end

  protected

  def delete_entry(key, options); end
  def key_matcher(pattern, options); end
  def read_entry(key, options); end
  def write_entry(key, entry, options); end

  private

  def expanded_key(key); end
  def get_entry_value(entry, name, options); end
  def handle_expired_entry(entry, key, options); end
  def instrument(operation, key, options = T.unsafe(nil)); end
  def log; end
  def merged_options(call_options); end
  def namespaced_key(*args); end
  def normalize_key(key, options); end
  def save_block_result_to_cache(name, options); end

  class << self
    def logger; end
    def logger=(obj); end
  end
end

module ActiveSupport::Cache::Strategy; end

module ActiveSupport::Cache::Strategy::LocalCache
  def cleanup(options = T.unsafe(nil)); end
  def clear(options = T.unsafe(nil)); end
  def decrement(name, amount = T.unsafe(nil), options = T.unsafe(nil)); end
  def increment(name, amount = T.unsafe(nil), options = T.unsafe(nil)); end
  def middleware; end
  def with_local_cache; end

  protected

  def delete_entry(key, options); end
  def read_entry(key, options); end
  def set_cache_value(value, name, amount, options); end
  def write_cache_value(name, value, options); end
  def write_entry(key, entry, options); end

  private

  def bypass_local_cache; end
  def local_cache; end
  def local_cache_key; end
  def use_temporary_local_cache(temporary_cache); end
end

class ActiveSupport::Cache::Strategy::LocalCache::LocalCacheRegistry
  extend ::ActiveSupport::PerThreadRegistry

  def initialize; end

  def cache_for(local_cache_key); end
  def set_cache_for(local_cache_key, value); end

  class << self
    def cache_for(l); end
    def set_cache_for(l, v); end
  end
end

class ActiveSupport::Cache::Strategy::LocalCache::LocalStore < ::ActiveSupport::Cache::Store
  def initialize; end

  def clear(options = T.unsafe(nil)); end
  def delete_entry(key, options); end
  def fetch_entry(key, options = T.unsafe(nil)); end
  def read_entry(key, options); end
  def synchronize; end
  def write_entry(key, value, options); end
end

class ActiveSupport::Cache::Strategy::LocalCache::Middleware
  def initialize(name, local_cache_key); end

  def call(env); end
  def local_cache_key; end
  def name; end
  def new(app); end
end

ActiveSupport::Cache::UNIVERSAL_OPTIONS = T.let(T.unsafe(nil), Array)

class ActiveSupport::CachingKeyGenerator
  def initialize(key_generator); end

  def generate_key(*args); end
end

module ActiveSupport::Callbacks
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveSupport::Callbacks::ClassMethods

  def halt_and_display_warning_on_return_false; end
  def run_callbacks(kind, &block); end

  private

  def __run_callbacks__(callbacks, &block); end
  def halted_callback_hook(filter); end

  class << self
    def halt_and_display_warning_on_return_false; end
    def halt_and_display_warning_on_return_false=(obj); end
  end
end

ActiveSupport::Callbacks::CALLBACK_FILTER_TYPES = T.let(T.unsafe(nil), Array)

class ActiveSupport::Callbacks::Callback
  def initialize(name, filter, kind, options, chain_config); end

  def apply(callback_sequence); end
  def chain_config; end
  def duplicates?(other); end
  def filter; end
  def kind; end
  def kind=(_arg0); end
  def matches?(_kind, _filter); end
  def merge_conditional_options(chain, if_option:, unless_option:); end
  def name; end
  def name=(_arg0); end
  def raw_filter; end

  private

  def compute_identifier(filter); end
  def conditions_lambdas; end
  def invert_lambda(l); end
  def make_lambda(filter); end

  class << self
    def build(chain, filter, kind, options); end
  end
end

class ActiveSupport::Callbacks::CallbackChain
  include ::Enumerable

  def initialize(name, config); end

  def append(*callbacks); end
  def clear; end
  def compile; end
  def config; end
  def delete(o); end
  def each(&block); end
  def empty?; end
  def index(o); end
  def insert(index, o); end
  def name; end
  def prepend(*callbacks); end

  protected

  def chain; end

  private

  def append_one(callback); end
  def default_terminator; end
  def initialize_copy(other); end
  def prepend_one(callback); end
  def remove_duplicates(callback); end
end

class ActiveSupport::Callbacks::CallbackSequence
  def initialize(&call); end

  def after(&after); end
  def around(&around); end
  def before(&before); end
  def call(arg); end
end

module ActiveSupport::Callbacks::ClassMethods
  def __update_callbacks(name); end
  def define_callbacks(*names); end
  def normalize_callback_params(filters, block); end
  def reset_callbacks(name); end
  def set_callback(name, *filter_list, &block); end
  def skip_callback(name, *filter_list, &block); end

  protected

  def deprecated_false_terminator; end
  def get_callbacks(name); end
  def set_callbacks(name, callbacks); end

  private

  def display_deprecation_warning_for_false_terminator; end
end

module ActiveSupport::Callbacks::Conditionals; end

class ActiveSupport::Callbacks::Conditionals::Value
  def initialize(&block); end

  def call(target, value); end
end

module ActiveSupport::Callbacks::Filters; end

class ActiveSupport::Callbacks::Filters::After
  class << self
    def build(callback_sequence, user_callback, user_conditions, chain_config); end

    private

    def conditional(callback_sequence, user_callback, user_conditions); end
    def halting(callback_sequence, user_callback); end
    def halting_and_conditional(callback_sequence, user_callback, user_conditions); end
    def simple(callback_sequence, user_callback); end
  end
end

class ActiveSupport::Callbacks::Filters::Around
  class << self
    def build(callback_sequence, user_callback, user_conditions, chain_config); end

    private

    def halting(callback_sequence, user_callback); end
    def halting_and_conditional(callback_sequence, user_callback, user_conditions); end
  end
end

class ActiveSupport::Callbacks::Filters::Before
  class << self
    def build(callback_sequence, user_callback, user_conditions, chain_config, filter); end

    private

    def halting(callback_sequence, user_callback, halted_lambda, filter); end
    def halting_and_conditional(callback_sequence, user_callback, user_conditions, halted_lambda, filter); end
  end
end

ActiveSupport::Callbacks::Filters::ENDING = T.let(T.unsafe(nil), ActiveSupport::Callbacks::Filters::End)

class ActiveSupport::Callbacks::Filters::End
  def call(env); end
end

class ActiveSupport::Callbacks::Filters::Environment < ::Struct
  def halted; end
  def halted=(_); end
  def run_block; end
  def run_block=(_); end
  def target; end
  def target=(_); end
  def value; end
  def value=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

module ActiveSupport::Concern
  def append_features(base); end
  def class_methods(&class_methods_module_definition); end
  def included(base = T.unsafe(nil), &block); end

  class << self
    def extended(base); end
  end
end

class ActiveSupport::Concern::MultipleIncludedBlocks < ::StandardError
  def initialize; end
end

module ActiveSupport::Concurrency; end

class ActiveSupport::Concurrency::ShareLock
  include ::MonitorMixin

  def initialize; end

  def exclusive(purpose: T.unsafe(nil), compatible: T.unsafe(nil), after_compatible: T.unsafe(nil), no_wait: T.unsafe(nil)); end
  def raw_state; end
  def sharing; end
  def start_exclusive(purpose: T.unsafe(nil), compatible: T.unsafe(nil), no_wait: T.unsafe(nil)); end
  def start_sharing; end
  def stop_exclusive(compatible: T.unsafe(nil)); end
  def stop_sharing; end
  def yield_shares(purpose: T.unsafe(nil), compatible: T.unsafe(nil), block_share: T.unsafe(nil)); end

  private

  def busy_for_exclusive?(purpose); end
  def busy_for_sharing?(purpose); end
  def eligible_waiters?(compatible); end
  def wait_for(method); end
end

module ActiveSupport::Configurable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveSupport::Configurable::ClassMethods

  def config; end
end

module ActiveSupport::Configurable::ClassMethods
  def config; end
  def configure; end

  private

  def config_accessor(*names); end
end

class ActiveSupport::Configurable::Configuration < ::ActiveSupport::InheritableOptions
  def compile_methods!; end

  class << self
    def compile_methods!(keys); end
  end
end

module ActiveSupport::Dependencies
  extend ::ActiveSupport::Dependencies

  def autoload_module!(into, const_name, qualified_name, path_suffix); end
  def autoload_once_paths; end
  def autoload_once_paths=(obj); end
  def autoload_paths; end
  def autoload_paths=(obj); end
  def autoloadable_module?(path_suffix); end
  def autoloaded?(desc); end
  def autoloaded_constants; end
  def autoloaded_constants=(obj); end
  def clear; end
  def constant_watch_stack; end
  def constant_watch_stack=(obj); end
  def constantize(name); end
  def depend_on(file_name, message = T.unsafe(nil)); end
  def explicitly_unloadable_constants; end
  def explicitly_unloadable_constants=(obj); end
  def history; end
  def history=(obj); end
  def hook!; end
  def interlock; end
  def interlock=(obj); end
  def load?; end
  def load_file(path, const_paths = T.unsafe(nil)); end
  def load_missing_constant(from_mod, const_name); end
  def load_once_path?(path); end
  def loadable_constants_for_path(path, bases = T.unsafe(nil)); end
  def loaded; end
  def loaded=(obj); end
  def loading; end
  def loading=(obj); end
  def mark_for_unload(const_desc); end
  def mechanism; end
  def mechanism=(obj); end
  def new_constants_in(*descs); end
  def qualified_const_defined?(path); end
  def qualified_name_for(mod, name); end
  def reference(klass); end
  def remove_constant(const); end
  def remove_unloadable_constants!; end
  def require_or_load(file_name, const_path = T.unsafe(nil)); end
  def safe_constantize(name); end
  def search_for_file(path_suffix); end
  def to_constant_name(desc); end
  def unhook!; end
  def warnings_on_first_load; end
  def warnings_on_first_load=(obj); end
  def will_unload?(const_desc); end

  class << self
    def autoload_once_paths; end
    def autoload_once_paths=(obj); end
    def autoload_paths; end
    def autoload_paths=(obj); end
    def autoloaded_constants; end
    def autoloaded_constants=(obj); end
    def constant_watch_stack; end
    def constant_watch_stack=(obj); end
    def explicitly_unloadable_constants; end
    def explicitly_unloadable_constants=(obj); end
    def history; end
    def history=(obj); end
    def interlock; end
    def interlock=(obj); end
    def load_interlock; end
    def loaded; end
    def loaded=(obj); end
    def loading; end
    def loading=(obj); end
    def mechanism; end
    def mechanism=(obj); end
    def run_interlock; end
    def unload_interlock; end
    def warnings_on_first_load; end
    def warnings_on_first_load=(obj); end
  end
end

module ActiveSupport::Dependencies::Blamable
  def blame_file!(file); end
  def blamed_files; end
  def copy_blame!(exc); end
  def describe_blame; end
end

class ActiveSupport::Dependencies::ClassCache
  def initialize; end

  def [](key); end
  def clear!; end
  def empty?; end
  def get(key); end
  def key?(key); end
  def safe_get(key); end
  def store(klass); end
end

class ActiveSupport::Dependencies::Interlock
  def initialize; end

  def done_running; end
  def done_unloading; end
  def loading; end
  def permit_concurrent_loads; end
  def raw_state(&block); end
  def running; end
  def start_running; end
  def start_unloading; end
  def unloading; end
end

module ActiveSupport::Dependencies::Loadable
  def load_dependency(file); end
  def require_dependency(file_name, message = T.unsafe(nil)); end
  def require_or_load(file_name); end
  def unloadable(const_desc); end

  private

  def load(file, wrap = T.unsafe(nil)); end
  def require(file); end

  class << self
    def exclude_from(base); end
  end
end

module ActiveSupport::Dependencies::ModuleConstMissing
  def const_missing(const_name); end
  def guess_for_anonymous(const_name); end
  def unloadable(const_desc = T.unsafe(nil)); end

  class << self
    def append_features(base); end
    def exclude_from(base); end
  end
end

ActiveSupport::Dependencies::Reference = T.let(T.unsafe(nil), ActiveSupport::Dependencies::ClassCache)

class ActiveSupport::Dependencies::WatchStack
  include ::Enumerable

  def initialize; end

  def each(&block); end
  def new_constants; end
  def watch_namespaces(namespaces); end
  def watching?; end

  private

  def pop_modules(modules); end
end

class ActiveSupport::Deprecation
  extend ::ActiveSupport::Deprecation::InstanceDelegator::OverrideDelegators
  include ::ActiveSupport::Deprecation::InstanceDelegator
  include ::ActiveSupport::Deprecation::Behavior
  include ::ActiveSupport::Deprecation::Reporting
  include ::ActiveSupport::Deprecation::MethodWrapper
  extend ::Singleton::SingletonClassMethods
  extend ::ActiveSupport::Deprecation::InstanceDelegator::ClassMethods
  include ::Singleton

  def initialize(deprecation_horizon = T.unsafe(nil), gem_name = T.unsafe(nil)); end

  def deprecation_horizon; end
  def deprecation_horizon=(_arg0); end

  class << self
    def behavior(*args, &block); end
    def behavior=(arg); end
    def debug(*args, &block); end
    def debug=(arg); end
    def deprecate_methods(*args, &block); end
    def deprecation_horizon(*args, &block); end
    def deprecation_horizon=(arg); end
    def gem_name(*args, &block); end
    def gem_name=(arg); end
    def silence(*args, &block); end
    def silenced(*args, &block); end
    def silenced=(arg); end
  end
end

module ActiveSupport::Deprecation::Behavior
  def behavior; end
  def behavior=(behavior); end
  def debug; end
  def debug=(_arg0); end
end

ActiveSupport::Deprecation::DEFAULT_BEHAVIORS = T.let(T.unsafe(nil), Hash)

class ActiveSupport::Deprecation::DeprecatedConstantProxy < ::ActiveSupport::Deprecation::DeprecationProxy
  def initialize(old_const, new_const, deprecator = T.unsafe(nil)); end

  def class; end

  private

  def target; end
  def warn(callstack, called, args); end
end

class ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy < ::ActiveSupport::Deprecation::DeprecationProxy
  def initialize(instance, method, var = T.unsafe(nil), deprecator = T.unsafe(nil)); end

  private

  def target; end
  def warn(callstack, called, args); end
end

class ActiveSupport::Deprecation::DeprecatedObjectProxy < ::ActiveSupport::Deprecation::DeprecationProxy
  def initialize(object, message, deprecator = T.unsafe(nil)); end

  private

  def target; end
  def warn(callstack, called, args); end
end

class ActiveSupport::Deprecation::DeprecationProxy
  def inspect; end

  private

  def method_missing(called, *args, &block); end

  class << self
    def new(*args, &block); end
  end
end

module ActiveSupport::Deprecation::InstanceDelegator
  mixes_in_class_methods ::ActiveSupport::Deprecation::InstanceDelegator::OverrideDelegators

  class << self
    def included(base); end
  end
end

module ActiveSupport::Deprecation::InstanceDelegator::ClassMethods
  def include(included_module); end
  def method_added(method_name); end
end

module ActiveSupport::Deprecation::InstanceDelegator::OverrideDelegators
  def deprecation_warning(deprecated_method_name, message = T.unsafe(nil), caller_backtrace = T.unsafe(nil)); end
  def warn(message = T.unsafe(nil), callstack = T.unsafe(nil)); end
end

module ActiveSupport::Deprecation::MethodWrapper
  def deprecate_methods(target_module, *method_names); end
end

module ActiveSupport::Deprecation::Reporting
  def deprecation_warning(deprecated_method_name, message = T.unsafe(nil), caller_backtrace = T.unsafe(nil)); end
  def gem_name; end
  def gem_name=(_arg0); end
  def silence; end
  def silenced; end
  def silenced=(_arg0); end
  def warn(message = T.unsafe(nil), callstack = T.unsafe(nil)); end

  private

  def _extract_callstack(callstack); end
  def deprecated_method_warning(method_name, message = T.unsafe(nil)); end
  def deprecation_caller_message(callstack); end
  def deprecation_message(callstack, message = T.unsafe(nil)); end
  def extract_callstack(callstack); end
  def ignored_callstack(path); end
end

ActiveSupport::Deprecation::Reporting::RAILS_GEM_ROOT = T.let(T.unsafe(nil), String)
class ActiveSupport::DeprecationException < ::StandardError; end

module ActiveSupport::DescendantsTracker
  def descendants; end
  def direct_descendants; end
  def inherited(base); end

  class << self
    def clear; end
    def descendants(klass); end
    def direct_descendants(klass); end
    def store_inherited(klass, descendant); end

    private

    def accumulate_descendants(klass, acc); end
  end
end

class ActiveSupport::Duration
  def initialize(value, parts); end

  def +(other); end
  def -(other); end
  def -@; end
  def <=>(*args, &block); end
  def ==(other); end
  def ago(time = T.unsafe(nil)); end
  def as_json(options = T.unsafe(nil)); end
  def eql?(other); end
  def from_now(time = T.unsafe(nil)); end
  def hash; end
  def inspect; end
  def instance_of?(klass); end
  def is_a?(klass); end
  def iso8601(precision: T.unsafe(nil)); end
  def kind_of?(klass); end
  def parts; end
  def parts=(_arg0); end
  def since(time = T.unsafe(nil)); end
  def to_i; end
  def to_s; end
  def until(time = T.unsafe(nil)); end
  def value; end
  def value=(_arg0); end

  protected

  def sum(sign, time = T.unsafe(nil)); end

  private

  def method_missing(method, *args, &block); end
  def respond_to_missing?(method, include_private = T.unsafe(nil)); end

  class << self
    def ===(other); end
    def days(value); end
    def hours(value); end
    def minutes(value); end
    def months(value); end
    def parse(iso8601duration); end
    def seconds(value); end
    def weeks(value); end
    def years(value); end

    private

    def calculate_total_seconds(parts); end
  end
end

class ActiveSupport::Duration::ISO8601Parser
  def initialize(string); end

  def mode; end
  def mode=(_arg0); end
  def parse!; end
  def parts; end
  def scanner; end
  def sign; end
  def sign=(_arg0); end

  private

  def finished?; end
  def number; end
  def raise_parsing_error(reason = T.unsafe(nil)); end
  def scan(pattern); end
  def validate!; end
end

ActiveSupport::Duration::ISO8601Parser::COMMA = T.let(T.unsafe(nil), String)
ActiveSupport::Duration::ISO8601Parser::DATE_COMPONENT = T.let(T.unsafe(nil), Regexp)
ActiveSupport::Duration::ISO8601Parser::DATE_COMPONENTS = T.let(T.unsafe(nil), Array)
ActiveSupport::Duration::ISO8601Parser::DATE_MARKER = T.let(T.unsafe(nil), Regexp)
ActiveSupport::Duration::ISO8601Parser::DATE_TO_PART = T.let(T.unsafe(nil), Hash)
ActiveSupport::Duration::ISO8601Parser::PERIOD = T.let(T.unsafe(nil), String)
ActiveSupport::Duration::ISO8601Parser::PERIOD_OR_COMMA = T.let(T.unsafe(nil), Regexp)
class ActiveSupport::Duration::ISO8601Parser::ParsingError < ::ArgumentError; end
ActiveSupport::Duration::ISO8601Parser::SIGN_MARKER = T.let(T.unsafe(nil), Regexp)
ActiveSupport::Duration::ISO8601Parser::TIME_COMPONENT = T.let(T.unsafe(nil), Regexp)
ActiveSupport::Duration::ISO8601Parser::TIME_COMPONENTS = T.let(T.unsafe(nil), Array)
ActiveSupport::Duration::ISO8601Parser::TIME_MARKER = T.let(T.unsafe(nil), Regexp)
ActiveSupport::Duration::ISO8601Parser::TIME_TO_PART = T.let(T.unsafe(nil), Hash)

class ActiveSupport::Duration::ISO8601Serializer
  def initialize(duration, precision: T.unsafe(nil)); end

  def serialize; end

  private

  def normalize; end
end

ActiveSupport::Duration::PARTS_IN_SECONDS = T.let(T.unsafe(nil), Hash)
ActiveSupport::Duration::SECONDS_PER_DAY = T.let(T.unsafe(nil), Integer)
ActiveSupport::Duration::SECONDS_PER_HOUR = T.let(T.unsafe(nil), Integer)
ActiveSupport::Duration::SECONDS_PER_MINUTE = T.let(T.unsafe(nil), Integer)
ActiveSupport::Duration::SECONDS_PER_MONTH = T.let(T.unsafe(nil), Integer)
ActiveSupport::Duration::SECONDS_PER_WEEK = T.let(T.unsafe(nil), Integer)
ActiveSupport::Duration::SECONDS_PER_YEAR = T.let(T.unsafe(nil), Integer)

module ActiveSupport::EachTimeWithZone
  def each(&block); end
  def step(n = T.unsafe(nil), &block); end

  private

  def ensure_iteration_allowed; end
end

class ActiveSupport::EventedFileUpdateChecker
  def initialize(files, dirs = T.unsafe(nil), &block); end

  def execute; end
  def execute_if_updated; end
  def updated?; end

  private

  def boot!; end
  def changed(modified, added, removed); end
  def directories_to_watch; end
  def watching?(file); end
end

class ActiveSupport::EventedFileUpdateChecker::PathHelper
  def existing_parent(dir); end
  def filter_out_descendants(dirs); end
  def longest_common_subpath(paths); end
  def normalize_extension(ext); end
  def xpath(path); end

  private

  def ascendant_of?(base, other); end
end

class ActiveSupport::ExecutionWrapper
  include ::ActiveSupport::Callbacks
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker

  def _complete_callbacks; end
  def _complete_callbacks?; end
  def _run_callbacks; end
  def _run_callbacks?; end
  def _run_complete_callbacks(&block); end
  def _run_run_callbacks(&block); end
  def complete!; end
  def run!; end

  private

  def hook_state; end

  class << self
    def _complete_callbacks; end
    def _complete_callbacks=(val); end
    def _complete_callbacks?; end
    def _run_callbacks; end
    def _run_callbacks=(val); end
    def _run_callbacks?; end
    def active; end
    def active=(_arg0); end
    def active?; end
    def inherited(other); end
    def register_hook(hook, outer: T.unsafe(nil)); end
    def run!; end
    def to_complete(*args, &block); end
    def to_run(*args, &block); end
    def wrap; end
  end
end

class ActiveSupport::ExecutionWrapper::CompleteHook < ::Struct
  def after(target); end
  def before(target); end
end

ActiveSupport::ExecutionWrapper::Null = T.let(T.unsafe(nil), Object)

class ActiveSupport::ExecutionWrapper::RunHook < ::Struct
  def before(target); end
end

class ActiveSupport::Executor < ::ActiveSupport::ExecutionWrapper; end

class ActiveSupport::FileUpdateChecker
  def initialize(files, dirs = T.unsafe(nil), &block); end

  def execute; end
  def execute_if_updated; end
  def updated?; end

  private

  def compile_ext(array); end
  def compile_glob(hash); end
  def escape(key); end
  def max_mtime(paths); end
  def updated_at(paths); end
  def watched; end
end

module ActiveSupport::Gzip
  class << self
    def compress(source, level = T.unsafe(nil), strategy = T.unsafe(nil)); end
    def decompress(source); end
  end
end

class ActiveSupport::Gzip::Stream < ::StringIO
  def initialize(*_arg0); end

  def close; end
end

class ActiveSupport::HashWithIndifferentAccess < ::Hash
  def initialize(constructor = T.unsafe(nil)); end

  def [](key); end
  def []=(key, value); end
  def compact; end
  def deep_stringify_keys; end
  def deep_stringify_keys!; end
  def deep_symbolize_keys; end
  def default(*args); end
  def delete(key); end
  def dup; end
  def extractable_options?; end
  def fetch(key, *extras); end
  def has_key?(key); end
  def include?(key); end
  def key?(key); end
  def member?(key); end
  def merge(hash, &block); end
  def merge!(other_hash); end
  def nested_under_indifferent_access; end
  def regular_update(*_arg0); end
  def regular_writer(_arg0, _arg1); end
  def reject(*args, &block); end
  def replace(other_hash); end
  def reverse_merge(other_hash); end
  def reverse_merge!(other_hash); end
  def select(*args, &block); end
  def store(key, value); end
  def stringify_keys; end
  def stringify_keys!; end
  def symbolize_keys; end
  def to_hash; end
  def to_options!; end
  def transform_values(*args, &block); end
  def update(other_hash); end
  def values_at(*indices); end
  def with_indifferent_access; end

  protected

  def convert_key(key); end
  def convert_value(value, options = T.unsafe(nil)); end
  def set_defaults(target); end

  class << self
    def [](*args); end
    def new_from_hash_copying_default(hash); end
  end
end

module ActiveSupport::IncludeWithRange
  def include?(value); end
end

module ActiveSupport::Inflector
  extend ::ActiveSupport::Inflector

  def camelize(term, uppercase_first_letter = T.unsafe(nil)); end
  def classify(table_name); end
  def constantize(camel_cased_word); end
  def dasherize(underscored_word); end
  def deconstantize(path); end
  def demodulize(path); end
  def foreign_key(class_name, separate_class_name_and_id_with_underscore = T.unsafe(nil)); end
  def humanize(lower_case_and_underscored_word, options = T.unsafe(nil)); end
  def inflections(locale = T.unsafe(nil)); end
  def ordinal(number); end
  def ordinalize(number); end
  def parameterize(string, sep = T.unsafe(nil), separator: T.unsafe(nil), preserve_case: T.unsafe(nil)); end
  def pluralize(word, locale = T.unsafe(nil)); end
  def safe_constantize(camel_cased_word); end
  def singularize(word, locale = T.unsafe(nil)); end
  def tableize(class_name); end
  def titleize(word); end
  def transliterate(string, replacement = T.unsafe(nil)); end
  def underscore(camel_cased_word); end
  def upcase_first(string); end

  private

  def apply_inflections(word, rules); end
  def const_regexp(camel_cased_word); end
end

class ActiveSupport::Inflector::Inflections
  def initialize; end

  def acronym(word); end
  def acronym_regex; end
  def acronyms; end
  def clear(scope = T.unsafe(nil)); end
  def human(rule, replacement); end
  def humans; end
  def irregular(singular, plural); end
  def plural(rule, replacement); end
  def plurals; end
  def singular(rule, replacement); end
  def singulars; end
  def uncountable(*words); end
  def uncountables; end

  private

  def initialize_dup(orig); end

  class << self
    def instance(locale = T.unsafe(nil)); end
  end
end

class ActiveSupport::Inflector::Inflections::Uncountables < ::Array
  def initialize; end

  def <<(*word); end
  def add(words); end
  def delete(entry); end
  def uncountable?(str); end

  private

  def to_regex(string); end
end

class ActiveSupport::InheritableOptions < ::ActiveSupport::OrderedOptions
  def initialize(parent = T.unsafe(nil)); end

  def inheritable_copy; end
end

module ActiveSupport::JSON
  class << self
    def decode(json); end
    def encode(value, options = T.unsafe(nil)); end
    def parse_error; end

    private

    def convert_dates_from(data); end
  end
end

ActiveSupport::JSON::DATETIME_REGEX = T.let(T.unsafe(nil), Regexp)
ActiveSupport::JSON::DATE_REGEX = T.let(T.unsafe(nil), Regexp)

module ActiveSupport::JSON::Encoding
  class << self
    def escape_html_entities_in_json; end
    def escape_html_entities_in_json=(_arg0); end
    def json_encoder; end
    def json_encoder=(_arg0); end
    def time_precision; end
    def time_precision=(_arg0); end
    def use_standard_json_time_format; end
    def use_standard_json_time_format=(_arg0); end
  end
end

class ActiveSupport::JSON::Encoding::JSONGemEncoder
  def initialize(options = T.unsafe(nil)); end

  def encode(value); end
  def options; end

  private

  def jsonify(value); end
  def stringify(jsonified); end
end

ActiveSupport::JSON::Encoding::JSONGemEncoder::ESCAPED_CHARS = T.let(T.unsafe(nil), Hash)
ActiveSupport::JSON::Encoding::JSONGemEncoder::ESCAPE_REGEX_WITHOUT_HTML_ENTITIES = T.let(T.unsafe(nil), Regexp)
ActiveSupport::JSON::Encoding::JSONGemEncoder::ESCAPE_REGEX_WITH_HTML_ENTITIES = T.let(T.unsafe(nil), Regexp)

class ActiveSupport::JSON::Encoding::JSONGemEncoder::EscapedString < ::String
  def to_json(*_arg0); end
  def to_s; end
end

class ActiveSupport::KeyGenerator
  def initialize(secret, options = T.unsafe(nil)); end

  def generate_key(salt, key_size = T.unsafe(nil)); end
end

module ActiveSupport::LazyLoadHooks
  def on_load(name, options = T.unsafe(nil), &block); end
  def run_load_hooks(name, base = T.unsafe(nil)); end

  private

  def execute_hook(name, base, options, block); end
  def with_execution_control(name, block, once); end

  class << self
    def extended(base); end
  end
end

class ActiveSupport::LegacyKeyGenerator
  def initialize(secret); end

  def generate_key(salt); end

  private

  def ensure_secret_secure(secret); end
end

ActiveSupport::LegacyKeyGenerator::SECRET_MIN_LENGTH = T.let(T.unsafe(nil), Integer)

class ActiveSupport::LogSubscriber < ::ActiveSupport::Subscriber
  def colorize_logging; end
  def colorize_logging=(obj); end
  def debug(progname = T.unsafe(nil), &block); end
  def error(progname = T.unsafe(nil), &block); end
  def fatal(progname = T.unsafe(nil), &block); end
  def finish(name, id, payload); end
  def info(progname = T.unsafe(nil), &block); end
  def logger; end
  def start(name, id, payload); end
  def unknown(progname = T.unsafe(nil), &block); end
  def warn(progname = T.unsafe(nil), &block); end

  protected

  def color(text, color, bold = T.unsafe(nil)); end

  class << self
    def colorize_logging; end
    def colorize_logging=(obj); end
    def flush_all!; end
    def log_subscribers; end
    def logger; end
    def logger=(_arg0); end
  end
end

ActiveSupport::LogSubscriber::BLACK = T.let(T.unsafe(nil), String)
ActiveSupport::LogSubscriber::BLUE = T.let(T.unsafe(nil), String)
ActiveSupport::LogSubscriber::BOLD = T.let(T.unsafe(nil), String)
ActiveSupport::LogSubscriber::CLEAR = T.let(T.unsafe(nil), String)
ActiveSupport::LogSubscriber::CYAN = T.let(T.unsafe(nil), String)
ActiveSupport::LogSubscriber::GREEN = T.let(T.unsafe(nil), String)
ActiveSupport::LogSubscriber::MAGENTA = T.let(T.unsafe(nil), String)
ActiveSupport::LogSubscriber::RED = T.let(T.unsafe(nil), String)
ActiveSupport::LogSubscriber::WHITE = T.let(T.unsafe(nil), String)
ActiveSupport::LogSubscriber::YELLOW = T.let(T.unsafe(nil), String)

class ActiveSupport::Logger < ::Logger
  include ::ActiveSupport::LoggerThreadSafeLevel
  include ::LoggerSilence

  def initialize(*args); end

  def add(severity, message = T.unsafe(nil), progname = T.unsafe(nil), &block); end
  def debug?; end
  def error?; end
  def fatal?; end
  def info?; end
  def silencer; end
  def silencer=(obj); end
  def unknown?; end
  def warn?; end

  class << self
    def broadcast(logger); end
    def logger_outputs_to?(logger, *sources); end
    def silencer; end
    def silencer=(obj); end
  end
end

class ActiveSupport::Logger::SimpleFormatter < ::Logger::Formatter
  def call(severity, timestamp, progname, msg); end
end

module ActiveSupport::LoggerThreadSafeLevel
  extend ::ActiveSupport::Concern

  def after_initialize; end
  def level; end
  def local_level; end
  def local_level=(level); end
  def local_log_id; end
end

module ActiveSupport::MarshalWithAutoloading
  def load(source, proc = T.unsafe(nil)); end
end

class ActiveSupport::MessageEncryptor
  def initialize(secret, *signature_key_or_options); end

  def decrypt_and_verify(value); end
  def encrypt_and_sign(value); end

  private

  def _decrypt(encrypted_message); end
  def _encrypt(value); end
  def new_cipher; end
  def verifier; end

  class << self
    def key_len(cipher = T.unsafe(nil)); end
  end
end

ActiveSupport::MessageEncryptor::DEFAULT_CIPHER = T.let(T.unsafe(nil), String)
class ActiveSupport::MessageEncryptor::InvalidMessage < ::StandardError; end

module ActiveSupport::MessageEncryptor::NullSerializer
  class << self
    def dump(value); end
    def load(value); end
  end
end

ActiveSupport::MessageEncryptor::OpenSSLCipherError = OpenSSL::Cipher::CipherError

class ActiveSupport::MessageVerifier
  def initialize(secret, options = T.unsafe(nil)); end

  def generate(value); end
  def valid_message?(signed_message); end
  def verified(signed_message); end
  def verify(signed_message); end

  private

  def decode(data); end
  def encode(data); end
  def generate_digest(data); end
end

class ActiveSupport::MessageVerifier::InvalidSignature < ::StandardError; end

module ActiveSupport::Multibyte
  class << self
    def proxy_class; end
    def proxy_class=(klass); end
  end
end

class ActiveSupport::Multibyte::Chars
  include ::Comparable

  def initialize(string); end

  def <=>(*args, &block); end
  def =~(*args, &block); end
  def acts_like_string?(*args, &block); end
  def as_json(options = T.unsafe(nil)); end
  def capitalize; end
  def capitalize!(*args); end
  def compose; end
  def decompose; end
  def downcase; end
  def downcase!(*args); end
  def grapheme_length; end
  def limit(limit); end
  def method_missing(method, *args, &block); end
  def normalize(form = T.unsafe(nil)); end
  def reverse; end
  def reverse!(*args); end
  def slice!(*args); end
  def split(*args); end
  def swapcase; end
  def tidy_bytes(force = T.unsafe(nil)); end
  def tidy_bytes!(*args); end
  def titlecase; end
  def titleize; end
  def to_s; end
  def to_str; end
  def upcase; end
  def upcase!(*args); end
  def wrapped_string; end

  protected

  def chars(string); end
  def translate_offset(byte_offset); end

  private

  def respond_to_missing?(method, include_private); end

  class << self
    def consumes?(string); end
  end
end

module ActiveSupport::Multibyte::Unicode
  extend ::ActiveSupport::Multibyte::Unicode

  def compose(codepoints); end
  def decompose(type, codepoints); end
  def default_normalization_form; end
  def default_normalization_form=(_arg0); end
  def downcase(string); end
  def in_char_class?(codepoint, classes); end
  def normalize(string, form = T.unsafe(nil)); end
  def pack_graphemes(unpacked); end
  def reorder_characters(codepoints); end
  def swapcase(string); end
  def tidy_bytes(string, force = T.unsafe(nil)); end
  def unpack_graphemes(string); end
  def upcase(string); end

  private

  def apply_mapping(string, mapping); end
  def database; end
  def recode_windows1252_chars(string); end

  class << self
    def codepoints_to_pattern(array_of_codepoints); end
  end
end

class ActiveSupport::Multibyte::Unicode::Codepoint
  def initialize; end

  def code; end
  def code=(_arg0); end
  def combining_class; end
  def combining_class=(_arg0); end
  def decomp_mapping; end
  def decomp_mapping=(_arg0); end
  def decomp_type; end
  def decomp_type=(_arg0); end
  def lowercase_mapping; end
  def lowercase_mapping=(_arg0); end
  def swapcase_mapping; end
  def uppercase_mapping; end
  def uppercase_mapping=(_arg0); end
end

ActiveSupport::Multibyte::Unicode::HANGUL_JAMO_FIRST = T.let(T.unsafe(nil), Integer)
ActiveSupport::Multibyte::Unicode::HANGUL_JAMO_LAST = T.let(T.unsafe(nil), Integer)
ActiveSupport::Multibyte::Unicode::HANGUL_LBASE = T.let(T.unsafe(nil), Integer)
ActiveSupport::Multibyte::Unicode::HANGUL_LCOUNT = T.let(T.unsafe(nil), Integer)
ActiveSupport::Multibyte::Unicode::HANGUL_NCOUNT = T.let(T.unsafe(nil), Integer)
ActiveSupport::Multibyte::Unicode::HANGUL_SBASE = T.let(T.unsafe(nil), Integer)
ActiveSupport::Multibyte::Unicode::HANGUL_SCOUNT = T.let(T.unsafe(nil), Integer)
ActiveSupport::Multibyte::Unicode::HANGUL_SLAST = T.let(T.unsafe(nil), Integer)
ActiveSupport::Multibyte::Unicode::HANGUL_TBASE = T.let(T.unsafe(nil), Integer)
ActiveSupport::Multibyte::Unicode::HANGUL_TCOUNT = T.let(T.unsafe(nil), Integer)
ActiveSupport::Multibyte::Unicode::HANGUL_VBASE = T.let(T.unsafe(nil), Integer)
ActiveSupport::Multibyte::Unicode::HANGUL_VCOUNT = T.let(T.unsafe(nil), Integer)
ActiveSupport::Multibyte::Unicode::LEADERS_AND_TRAILERS = T.let(T.unsafe(nil), Array)
ActiveSupport::Multibyte::Unicode::LEADERS_PAT = T.let(T.unsafe(nil), Regexp)
ActiveSupport::Multibyte::Unicode::NORMALIZATION_FORMS = T.let(T.unsafe(nil), Array)
ActiveSupport::Multibyte::Unicode::TRAILERS_PAT = T.let(T.unsafe(nil), Regexp)
ActiveSupport::Multibyte::Unicode::UNICODE_VERSION = T.let(T.unsafe(nil), String)

class ActiveSupport::Multibyte::Unicode::UnicodeDatabase
  def initialize; end

  def boundary; end
  def boundary=(_arg0); end
  def codepoints; end
  def codepoints=(_arg0); end
  def composition_exclusion; end
  def composition_exclusion=(_arg0); end
  def composition_map; end
  def composition_map=(_arg0); end
  def cp1252; end
  def cp1252=(_arg0); end
  def load; end

  class << self
    def dirname; end
    def filename; end
  end
end

ActiveSupport::Multibyte::Unicode::UnicodeDatabase::ATTRIBUTES = T.let(T.unsafe(nil), Array)
ActiveSupport::Multibyte::Unicode::WHITESPACE = T.let(T.unsafe(nil), Array)

module ActiveSupport::Notifications
  class << self
    def instrument(name, payload = T.unsafe(nil)); end
    def instrumenter; end
    def notifier; end
    def notifier=(_arg0); end
    def publish(name, *args); end
    def subscribe(*args, &block); end
    def subscribed(callback, *args, &block); end
    def unsubscribe(subscriber_or_name); end
  end
end

class ActiveSupport::Notifications::Event
  def initialize(name, start, ending, transaction_id, payload); end

  def <<(event); end
  def children; end
  def duration; end
  def end; end
  def end=(_arg0); end
  def name; end
  def parent_of?(event); end
  def payload; end
  def time; end
  def transaction_id; end
end

class ActiveSupport::Notifications::Fanout
  include ::Mutex_m

  def initialize; end

  def finish(name, id, payload, listeners = T.unsafe(nil)); end
  def listeners_for(name); end
  def listening?(name); end
  def lock; end
  def locked?; end
  def publish(name, *args); end
  def start(name, id, payload); end
  def subscribe(pattern = T.unsafe(nil), block = T.unsafe(nil)); end
  def synchronize(&block); end
  def try_lock; end
  def unlock; end
  def unsubscribe(subscriber_or_name); end
  def wait; end
end

module ActiveSupport::Notifications::Fanout::Subscribers
  class << self
    def new(pattern, listener); end
  end
end

class ActiveSupport::Notifications::Fanout::Subscribers::AllMessages
  def initialize(delegate); end

  def finish(name, id, payload); end
  def matches?(_arg0); end
  def publish(name, *args); end
  def start(name, id, payload); end
  def subscribed_to?(name); end
end

class ActiveSupport::Notifications::Fanout::Subscribers::Evented
  def initialize(pattern, delegate); end

  def finish(name, id, payload); end
  def matches?(name); end
  def publish(name, *args); end
  def start(name, id, payload); end
  def subscribed_to?(name); end
end

class ActiveSupport::Notifications::Fanout::Subscribers::Timed < ::ActiveSupport::Notifications::Fanout::Subscribers::Evented
  def finish(name, id, payload); end
  def publish(name, *args); end
  def start(name, id, payload); end
end

class ActiveSupport::Notifications::InstrumentationRegistry
  extend ::ActiveSupport::PerThreadRegistry

  def initialize; end

  def instrumenter_for(notifier); end
end

class ActiveSupport::Notifications::Instrumenter
  def initialize(notifier); end

  def finish(name, payload); end
  def finish_with_state(listeners_state, name, payload); end
  def id; end
  def instrument(name, payload = T.unsafe(nil)); end
  def start(name, payload); end

  private

  def unique_id; end
end

module ActiveSupport::NumberHelper
  extend ::ActiveSupport::Autoload
  extend ::ActiveSupport::NumberHelper

  def number_to_currency(number, options = T.unsafe(nil)); end
  def number_to_delimited(number, options = T.unsafe(nil)); end
  def number_to_human(number, options = T.unsafe(nil)); end
  def number_to_human_size(number, options = T.unsafe(nil)); end
  def number_to_percentage(number, options = T.unsafe(nil)); end
  def number_to_phone(number, options = T.unsafe(nil)); end
  def number_to_rounded(number, options = T.unsafe(nil)); end
end

class ActiveSupport::NumberHelper::NumberConverter
  def initialize(number, options); end

  def execute; end
  def namespace; end
  def namespace=(_arg0); end
  def namespace?; end
  def number; end
  def opts; end
  def validate_float; end
  def validate_float=(_arg0); end
  def validate_float?; end

  private

  def default_format_options; end
  def default_value(key); end
  def format_options; end
  def i18n_format_options; end
  def options; end
  def translate_in_locale(key, i18n_options = T.unsafe(nil)); end
  def translate_number_value_with_default(key, i18n_options = T.unsafe(nil)); end
  def valid_float?; end

  class << self
    def convert(number, options); end
    def namespace; end
    def namespace=(val); end
    def namespace?; end
    def validate_float; end
    def validate_float=(val); end
    def validate_float?; end
  end
end

ActiveSupport::NumberHelper::NumberConverter::DEFAULTS = T.let(T.unsafe(nil), Hash)

class ActiveSupport::NumberHelper::NumberToCurrencyConverter < ::ActiveSupport::NumberHelper::NumberConverter
  def convert; end

  private

  def absolute_value(number); end
  def i18n_opts; end
  def options; end

  class << self
    def namespace; end
  end
end

class ActiveSupport::NumberHelper::NumberToDelimitedConverter < ::ActiveSupport::NumberHelper::NumberConverter
  def convert; end

  private

  def delimiter_pattern; end
  def parts; end

  class << self
    def validate_float; end
  end
end

ActiveSupport::NumberHelper::NumberToDelimitedConverter::DEFAULT_DELIMITER_REGEX = T.let(T.unsafe(nil), Regexp)

class ActiveSupport::NumberHelper::NumberToHumanConverter < ::ActiveSupport::NumberHelper::NumberConverter
  def convert; end

  private

  def calculate_exponent(units); end
  def determine_unit(units, exponent); end
  def format; end
  def unit_exponents(units); end

  class << self
    def namespace; end
    def validate_float; end
  end
end

ActiveSupport::NumberHelper::NumberToHumanConverter::DECIMAL_UNITS = T.let(T.unsafe(nil), Hash)
ActiveSupport::NumberHelper::NumberToHumanConverter::INVERTED_DECIMAL_UNITS = T.let(T.unsafe(nil), Hash)

class ActiveSupport::NumberHelper::NumberToHumanSizeConverter < ::ActiveSupport::NumberHelper::NumberConverter
  def convert; end

  private

  def base; end
  def conversion_format; end
  def exponent; end
  def smaller_than_base?; end
  def storage_unit_key; end
  def unit; end

  class << self
    def namespace; end
    def validate_float; end
  end
end

ActiveSupport::NumberHelper::NumberToHumanSizeConverter::STORAGE_UNITS = T.let(T.unsafe(nil), Array)

class ActiveSupport::NumberHelper::NumberToPercentageConverter < ::ActiveSupport::NumberHelper::NumberConverter
  def convert; end

  class << self
    def namespace; end
  end
end

class ActiveSupport::NumberHelper::NumberToPhoneConverter < ::ActiveSupport::NumberHelper::NumberConverter
  def convert; end

  private

  def convert_to_phone_number(number); end
  def convert_with_area_code(number); end
  def convert_without_area_code(number); end
  def country_code(code); end
  def delimiter; end
  def phone_ext(ext); end
  def regexp_pattern(default_pattern); end
  def start_with_delimiter?(number); end
end

class ActiveSupport::NumberHelper::NumberToRoundedConverter < ::ActiveSupport::NumberHelper::NumberConverter
  def convert; end

  private

  def absolute_number(number); end
  def calculate_rounded_number(multiplier); end
  def digit_count(number); end
  def digits_and_rounded_number(precision); end
  def format_number(number); end
  def strip_insignificant_zeros; end
  def zero?; end

  class << self
    def namespace; end
    def validate_float; end
  end
end

class ActiveSupport::OptionMerger
  def initialize(context, options); end

  private

  def method_missing(method, *arguments, &block); end
end

class ActiveSupport::OrderedHash < ::Hash
  def encode_with(coder); end
  def extractable_options?; end
  def nested_under_indifferent_access; end
  def reject(*args, &block); end
  def select(*args, &block); end
  def to_yaml_type; end
end

class ActiveSupport::OrderedOptions < ::Hash
  def [](key); end
  def []=(key, value); end
  def method_missing(name, *args); end

  protected

  def _get(_arg0); end

  private

  def respond_to_missing?(name, include_private); end
end

module ActiveSupport::PerThreadRegistry
  def instance; end

  protected

  def method_missing(name, *args, &block); end

  class << self
    def extended(object); end
  end
end

class ActiveSupport::ProxyObject < ::BasicObject
  def raise(*args); end
end

module ActiveSupport::QualifiedConstUtils
  class << self
    def names(path); end
    def raise_if_absolute(path); end
  end
end

class ActiveSupport::Railtie < ::Rails::Railtie; end

module ActiveSupport::RangeWithFormat
  def to_default_s(format = T.unsafe(nil)); end
  def to_formatted_s(format = T.unsafe(nil)); end
  def to_s(format = T.unsafe(nil)); end
end

ActiveSupport::RangeWithFormat::RANGE_FORMATS = T.let(T.unsafe(nil), Hash)

class ActiveSupport::Reloader < ::ActiveSupport::ExecutionWrapper
  def initialize; end

  def _class_unload_callbacks; end
  def _class_unload_callbacks?; end
  def _prepare_callbacks; end
  def _prepare_callbacks?; end
  def _run_class_unload_callbacks(&block); end
  def _run_prepare_callbacks(&block); end
  def check; end
  def check=(_arg0); end
  def check?; end
  def class_unload!(&block); end
  def complete!; end
  def executor; end
  def executor=(_arg0); end
  def executor?; end
  def release_unload_lock!; end
  def require_unload_lock!; end
  def run!; end

  class << self
    def _class_unload_callbacks; end
    def _class_unload_callbacks=(val); end
    def _class_unload_callbacks?; end
    def _prepare_callbacks; end
    def _prepare_callbacks=(val); end
    def _prepare_callbacks?; end
    def _run_callbacks; end
    def after_class_unload(*args, &block); end
    def before_class_unload(*args, &block); end
    def check; end
    def check!; end
    def check=(val); end
    def check?; end
    def executor; end
    def executor=(val); end
    def executor?; end
    def prepare!; end
    def reload!; end
    def reloaded!; end
    def run!; end
    def to_prepare(*args, &block); end
    def wrap; end
  end
end

module ActiveSupport::Rescuable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveSupport::Rescuable::ClassMethods

  def handler_for_rescue(exception); end
  def rescue_with_handler(exception); end
end

module ActiveSupport::Rescuable::ClassMethods
  def handler_for_rescue(exception, object: T.unsafe(nil)); end
  def rescue_from(*klasses, with: T.unsafe(nil), &block); end
  def rescue_with_handler(exception, object: T.unsafe(nil), visited_exceptions: T.unsafe(nil)); end

  private

  def constantize_rescue_handler_class(class_or_name); end
  def find_rescue_handler(exception); end
end

class ActiveSupport::SafeBuffer < ::String
  def initialize(str = T.unsafe(nil)); end

  def %(args); end
  def +(other); end
  def <<(value); end
  def [](*args); end
  def capitalize(*args, &block); end
  def capitalize!(*args); end
  def chomp(*args, &block); end
  def chomp!(*args); end
  def chop(*args, &block); end
  def chop!(*args); end
  def clone_empty; end
  def concat(value); end
  def delete(*args, &block); end
  def delete!(*args); end
  def downcase(*args, &block); end
  def downcase!(*args); end
  def encode_with(coder); end
  def gsub(*args, &block); end
  def gsub!(*args); end
  def html_safe?; end
  def lstrip(*args, &block); end
  def lstrip!(*args); end
  def next(*args, &block); end
  def next!(*args); end
  def prepend(value); end
  def reverse(*args, &block); end
  def reverse!(*args); end
  def rstrip(*args, &block); end
  def rstrip!(*args); end
  def safe_concat(value); end
  def slice(*args, &block); end
  def slice!(*args); end
  def squeeze(*args, &block); end
  def squeeze!(*args); end
  def strip(*args, &block); end
  def strip!(*args); end
  def sub(*args, &block); end
  def sub!(*args); end
  def succ(*args, &block); end
  def succ!(*args); end
  def swapcase(*args, &block); end
  def swapcase!(*args); end
  def to_param; end
  def to_s; end
  def tr(*args, &block); end
  def tr!(*args); end
  def tr_s(*args, &block); end
  def tr_s!(*args); end
  def upcase(*args, &block); end
  def upcase!(*args); end

  private

  def html_escape_interpolated_argument(arg); end
  def initialize_copy(other); end
  def original_concat(*_arg0); end
end

class ActiveSupport::SafeBuffer::SafeConcatError < ::StandardError
  def initialize; end
end

ActiveSupport::SafeBuffer::UNSAFE_STRING_METHODS = T.let(T.unsafe(nil), Array)

module ActiveSupport::SecurityUtils
  private

  def secure_compare(a, b); end
  def variable_size_secure_compare(a, b); end

  class << self
    def secure_compare(a, b); end
    def variable_size_secure_compare(a, b); end
  end
end

class ActiveSupport::StringInquirer < ::String
  private

  def method_missing(method_name, *arguments); end
  def respond_to_missing?(method_name, include_private = T.unsafe(nil)); end
end

class ActiveSupport::Subscriber
  def initialize; end

  def finish(name, id, payload); end
  def patterns; end
  def start(name, id, payload); end

  private

  def event_stack; end

  class << self
    def attach_to(namespace, subscriber = T.unsafe(nil), notifier = T.unsafe(nil)); end
    def method_added(event); end
    def subscribers; end

    protected

    def add_event_subscriber(event); end
    def namespace; end
    def notifier; end
    def subscriber; end
  end
end

class ActiveSupport::SubscriberQueueRegistry
  extend ::ActiveSupport::PerThreadRegistry

  def initialize; end

  def get_queue(queue_key); end
end

module ActiveSupport::TaggedLogging
  def clear_tags!(*args, &block); end
  def flush; end
  def pop_tags(*args, &block); end
  def push_tags(*args, &block); end
  def tagged(*tags); end

  class << self
    def new(logger); end
  end
end

module ActiveSupport::TaggedLogging::Formatter
  def call(severity, timestamp, progname, msg); end
  def clear_tags!; end
  def current_tags; end
  def pop_tags(size = T.unsafe(nil)); end
  def push_tags(*tags); end
  def tagged(*tags); end
  def tags_text; end
end

class ActiveSupport::TestCase < ::Minitest::Test
  extend ::ActiveSupport::Testing::Declarative
  include ::ActiveSupport::Testing::SetupAndTeardown
  include ::ActiveSupport::Callbacks
  include ::ActiveSupport::Testing::Assertions
  include ::ActiveSupport::Testing::Deprecation
  include ::ActiveSupport::Testing::TimeHelpers
  include ::ActiveSupport::Testing::FileFixtures
  extend ::ActiveSupport::Testing::SetupAndTeardown::ClassMethods
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker
  include ::ActiveSupport::Testing::TaggedLogging

  def _run_setup_callbacks(&block); end
  def _run_teardown_callbacks(&block); end
  def _setup_callbacks; end
  def _setup_callbacks?; end
  def _teardown_callbacks; end
  def _teardown_callbacks?; end
  def assert_no_match(matcher, obj, msg = T.unsafe(nil)); end
  def assert_not_empty(obj, msg = T.unsafe(nil)); end
  def assert_not_equal(exp, act, msg = T.unsafe(nil)); end
  def assert_not_in_delta(exp, act, delta = T.unsafe(nil), msg = T.unsafe(nil)); end
  def assert_not_in_epsilon(a, b, epsilon = T.unsafe(nil), msg = T.unsafe(nil)); end
  def assert_not_includes(collection, obj, msg = T.unsafe(nil)); end
  def assert_not_instance_of(cls, obj, msg = T.unsafe(nil)); end
  def assert_not_kind_of(cls, obj, msg = T.unsafe(nil)); end
  def assert_not_nil(obj, msg = T.unsafe(nil)); end
  def assert_not_operator(o1, op, o2 = T.unsafe(nil), msg = T.unsafe(nil)); end
  def assert_not_predicate(o1, op, msg = T.unsafe(nil)); end
  def assert_not_respond_to(obj, meth, msg = T.unsafe(nil)); end
  def assert_not_same(exp, act, msg = T.unsafe(nil)); end
  def assert_nothing_raised(*args); end
  def assert_raise(*exp); end
  def file_fixture_path; end
  def file_fixture_path?; end
  def method_name; end

  class << self
    def _setup_callbacks; end
    def _setup_callbacks=(val); end
    def _setup_callbacks?; end
    def _teardown_callbacks; end
    def _teardown_callbacks=(val); end
    def _teardown_callbacks?; end
    def file_fixture_path; end
    def file_fixture_path=(val); end
    def file_fixture_path?; end
    def test_order; end
    def test_order=(new_order); end
  end
end

ActiveSupport::TestCase::Assertion = Minitest::Assertion
module ActiveSupport::Testing; end

module ActiveSupport::Testing::Assertions
  def assert_difference(expression, difference = T.unsafe(nil), message = T.unsafe(nil), &block); end
  def assert_no_difference(expression, message = T.unsafe(nil), &block); end
  def assert_not(object, message = T.unsafe(nil)); end
end

module ActiveSupport::Testing::ConstantLookup
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveSupport::Testing::ConstantLookup::ClassMethods
end

module ActiveSupport::Testing::ConstantLookup::ClassMethods
  def determine_constant_from_test_name(test_name); end
end

module ActiveSupport::Testing::Declarative
  def test(name, &block); end
end

module ActiveSupport::Testing::Deprecation
  def assert_deprecated(match = T.unsafe(nil), deprecator = T.unsafe(nil), &block); end
  def assert_not_deprecated(deprecator = T.unsafe(nil), &block); end
  def collect_deprecations(deprecator = T.unsafe(nil)); end
end

module ActiveSupport::Testing::FileFixtures
  extend ::ActiveSupport::Concern

  def file_fixture(fixture_name); end
end

module ActiveSupport::Testing::Isolation
  include ::ActiveSupport::Testing::Isolation::Forking

  def _run_class_setup; end
  def run; end

  class << self
    def forking_env?; end
    def included(klass); end
  end
end

module ActiveSupport::Testing::Isolation::Forking
  def run_in_isolation(&blk); end
end

module ActiveSupport::Testing::Isolation::Subprocess
  def run_in_isolation(&blk); end
end

ActiveSupport::Testing::Isolation::Subprocess::ORIG_ARGV = T.let(T.unsafe(nil), Array)

module ActiveSupport::Testing::SetupAndTeardown
  extend ::ActiveSupport::Concern
  include ::ActiveSupport::Callbacks

  mixes_in_class_methods ::ActiveSupport::Testing::SetupAndTeardown::ClassMethods

  def after_teardown; end
  def before_setup; end
end

module ActiveSupport::Testing::SetupAndTeardown::ClassMethods
  def setup(*args, &block); end
  def teardown(*args, &block); end
end

class ActiveSupport::Testing::SimpleStubs
  def initialize; end

  def stub_object(object, method_name, &block); end
  def unstub_all!; end

  private

  def unstub_object(stub); end
end

class ActiveSupport::Testing::SimpleStubs::Stub < ::Struct
  def method_name; end
  def method_name=(_); end
  def object; end
  def object=(_); end
  def original_method; end
  def original_method=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

module ActiveSupport::Testing::TaggedLogging
  def before_setup; end
  def tagged_logger=(_arg0); end

  private

  def tagged_logger; end
end

module ActiveSupport::Testing::TimeHelpers
  def travel(duration, &block); end
  def travel_back; end
  def travel_to(date_or_time); end

  private

  def simple_stubs; end
end

class ActiveSupport::TimeWithZone
  include ::DateAndTime::Compatibility
  include ::Comparable

  def initialize(utc_time, time_zone, local_time = T.unsafe(nil), period = T.unsafe(nil)); end

  def +(other); end
  def -(other); end
  def <=>(other); end
  def acts_like_time?; end
  def advance(options); end
  def ago(other); end
  def as_json(options = T.unsafe(nil)); end
  def between?(min, max); end
  def blank?; end
  def comparable_time; end
  def day; end
  def dst?; end
  def encode_with(coder); end
  def eql?(other); end
  def formatted_offset(colon = T.unsafe(nil), alternate_utc_string = T.unsafe(nil)); end
  def freeze; end
  def future?; end
  def getgm; end
  def getlocal(utc_offset = T.unsafe(nil)); end
  def getutc; end
  def gmt?; end
  def gmt_offset; end
  def gmtime; end
  def gmtoff; end
  def hash; end
  def hour; end
  def httpdate; end
  def in(other); end
  def in_time_zone(new_zone = T.unsafe(nil)); end
  def init_with(coder); end
  def inspect; end
  def is_a?(klass); end
  def isdst; end
  def iso8601(fraction_digits = T.unsafe(nil)); end
  def kind_of?(klass); end
  def localtime(utc_offset = T.unsafe(nil)); end
  def marshal_dump; end
  def marshal_load(variables); end
  def mday; end
  def method_missing(sym, *args, &block); end
  def min; end
  def mon; end
  def month; end
  def nsec; end
  def past?; end
  def period; end
  def respond_to?(sym, include_priv = T.unsafe(nil)); end
  def rfc2822; end
  def rfc822; end
  def sec; end
  def since(other); end
  def strftime(format); end
  def time; end
  def time_zone; end
  def to_a; end
  def to_date; end
  def to_datetime; end
  def to_f; end
  def to_formatted_s(format = T.unsafe(nil)); end
  def to_i; end
  def to_r; end
  def to_s(format = T.unsafe(nil)); end
  def to_time; end
  def today?; end
  def tv_sec; end
  def usec; end
  def utc; end
  def utc?; end
  def utc_offset; end
  def wday; end
  def xmlschema(fraction_digits = T.unsafe(nil)); end
  def yday; end
  def year; end
  def zone; end

  private

  def duration_of_variable_length?(obj); end
  def get_period_and_ensure_valid_local_time(period); end
  def respond_to_missing?(sym, include_priv); end
  def transfer_time_values_to_utc_constructor(time); end
  def wrap_with_time_zone(time); end

  class << self
    def name; end
  end
end

ActiveSupport::TimeWithZone::PRECISIONS = T.let(T.unsafe(nil), Hash)

class ActiveSupport::TimeZone
  include ::Comparable

  def initialize(name, utc_offset = T.unsafe(nil), tzinfo = T.unsafe(nil)); end

  def <=>(zone); end
  def =~(re); end
  def at(secs); end
  def encode_with(coder); end
  def formatted_offset(colon = T.unsafe(nil), alternate_utc_string = T.unsafe(nil)); end
  def init_with(coder); end
  def local(*args); end
  def local_to_utc(time, dst = T.unsafe(nil)); end
  def name; end
  def now; end
  def parse(str, now = T.unsafe(nil)); end
  def period_for_local(time, dst = T.unsafe(nil)); end
  def period_for_utc(time); end
  def periods_for_local(time); end
  def strptime(str, format, now = T.unsafe(nil)); end
  def to_s; end
  def today; end
  def tomorrow; end
  def tzinfo; end
  def utc_offset; end
  def utc_to_local(time); end
  def yesterday; end

  private

  def parts_to_time(parts, now); end
  def time_now; end

  class << self
    def [](arg); end
    def all; end
    def country_zones(country_code); end
    def create(*_arg0); end
    def find_tzinfo(name); end
    def new(name); end
    def seconds_to_utc_offset(seconds, colon = T.unsafe(nil)); end
    def us_zones; end

    private

    def load_country_zones(code); end
    def zones_map; end
  end
end

ActiveSupport::TimeZone::MAPPING = T.let(T.unsafe(nil), Hash)
ActiveSupport::TimeZone::UTC_OFFSET_WITHOUT_COLON = T.let(T.unsafe(nil), String)
ActiveSupport::TimeZone::UTC_OFFSET_WITH_COLON = T.let(T.unsafe(nil), String)

module ActiveSupport::ToJsonWithActiveSupportEncoder
  def to_json(options = T.unsafe(nil)); end
end

module ActiveSupport::Tryable
  def try(*a, &b); end
  def try!(*a, &b); end
end

module ActiveSupport::VERSION; end
ActiveSupport::VERSION::MAJOR = T.let(T.unsafe(nil), Integer)
ActiveSupport::VERSION::MINOR = T.let(T.unsafe(nil), Integer)
ActiveSupport::VERSION::PRE = T.let(T.unsafe(nil), String)
ActiveSupport::VERSION::STRING = T.let(T.unsafe(nil), String)
ActiveSupport::VERSION::TINY = T.let(T.unsafe(nil), Integer)

class ActiveSupport::XMLConverter
  def initialize(xml, disallowed_types = T.unsafe(nil)); end

  def to_h; end

  private

  def become_array?(value); end
  def become_content?(value); end
  def become_empty_string?(value); end
  def become_hash?(value); end
  def deep_to_h(value); end
  def garbage?(value); end
  def normalize_keys(params); end
  def nothing?(value); end
  def process_array(value); end
  def process_content(value); end
  def process_hash(value); end
end

ActiveSupport::XMLConverter::DISALLOWED_TYPES = T.let(T.unsafe(nil), Array)

class ActiveSupport::XMLConverter::DisallowedType < ::StandardError
  def initialize(type); end
end

module ActiveSupport::XmlMini
  extend ::ActiveSupport::XmlMini

  def backend; end
  def backend=(name); end
  def depth; end
  def depth=(_arg0); end
  def parse(*args, &block); end
  def rename_key(key, options = T.unsafe(nil)); end
  def to_tag(key, value, options); end
  def with_backend(name); end

  protected

  def _dasherize(key); end
  def _parse_binary(bin, entity); end
  def _parse_file(file, entity); end

  private

  def cast_backend_name_to_module(name); end
  def current_thread_backend; end
  def current_thread_backend=(name); end
end

ActiveSupport::XmlMini::DEFAULT_ENCODINGS = T.let(T.unsafe(nil), Hash)
ActiveSupport::XmlMini::FORMATTING = T.let(T.unsafe(nil), Hash)

module ActiveSupport::XmlMini::FileLike
  def content_type; end
  def content_type=(_arg0); end
  def original_filename; end
  def original_filename=(_arg0); end
end

ActiveSupport::XmlMini::PARSING = T.let(T.unsafe(nil), Hash)
ActiveSupport::XmlMini::TYPE_NAMES = T.let(T.unsafe(nil), Hash)

module ActiveSupport::XmlMini_REXML
  extend ::ActiveSupport::XmlMini_REXML

  def parse(data); end

  private

  def collapse(element, depth); end
  def empty_content?(element); end
  def get_attributes(element); end
  def merge!(hash, key, value); end
  def merge_element!(hash, element, depth); end
  def merge_texts!(hash, element); end
end

ActiveSupport::XmlMini_REXML::CONTENT_KEY = T.let(T.unsafe(nil), String)

class Array
  include ::Enumerable
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  include ::Mocha::Inspect::ArrayMethods

  def as_json(options = T.unsafe(nil)); end
  def deep_dup; end
  def extract_options!; end
  def fifth; end
  def forty_two; end
  def fourth; end
  def from(position); end
  def in_groups(number, fill_with = T.unsafe(nil)); end
  def in_groups_of(number, fill_with = T.unsafe(nil)); end
  def inquiry; end
  def second; end
  def second_to_last; end
  def split(value = T.unsafe(nil)); end
  def sum(*args); end
  def third; end
  def third_to_last; end
  def to(position); end
  def to_formatted_s(format = T.unsafe(nil)); end
  def to_param; end
  def to_query(key); end
  def to_s(format = T.unsafe(nil)); end
  def to_sentence(options = T.unsafe(nil)); end
  def to_xml(options = T.unsafe(nil)); end
  def without(*elements); end

  class << self
    def wrap(object); end
  end
end

class BigDecimal < ::Numeric
  include ::ActiveSupport::BigDecimalWithDefaultFormat

  def as_json(options = T.unsafe(nil)); end
  def duplicable?; end
end

BigDecimal::EXCEPTION_NaN = T.let(T.unsafe(nil), Integer)
BigDecimal::VERSION = T.let(T.unsafe(nil), String)

class Class < ::Module
  include ::Mocha::ClassMethods

  def class_attribute(*attrs); end
  def descendants; end
  def subclasses; end
end

class Date
  include ::Comparable
  include ::DateAndTime::Zones
  include ::DateAndTime::Calculations
  include ::Mocha::Inspect::DateMethods

  def +(other); end
  def -(other); end
  def <=>(other); end
  def acts_like_date?; end
  def advance(options); end
  def ago(seconds); end
  def as_json(options = T.unsafe(nil)); end
  def at_beginning_of_day; end
  def at_end_of_day; end
  def at_midday; end
  def at_middle_of_day; end
  def at_midnight; end
  def at_noon; end
  def beginning_of_day; end
  def blank?; end
  def change(options); end
  def compare_with_coercion(other); end
  def end_of_day; end
  def in(seconds); end
  def inspect; end
  def midday; end
  def middle_of_day; end
  def midnight; end
  def minus_with_duration(other); end
  def noon; end
  def plus_with_duration(other); end
  def readable_inspect; end
  def since(seconds); end
  def to_formatted_s(format = T.unsafe(nil)); end
  def to_s(format = T.unsafe(nil)); end
  def to_time(form = T.unsafe(nil)); end
  def xmlschema; end

  class << self
    def beginning_of_week; end
    def beginning_of_week=(week_start); end
    def beginning_of_week_default; end
    def beginning_of_week_default=(_arg0); end
    def current; end
    def find_beginning_of_week!(week_start); end
    def tomorrow; end
    def yesterday; end
  end
end

Date::DATE_FORMATS = T.let(T.unsafe(nil), Hash)
module DateAndTime; end

module DateAndTime::Calculations
  def all_month; end
  def all_quarter; end
  def all_week(start_day = T.unsafe(nil)); end
  def all_year; end
  def at_beginning_of_month; end
  def at_beginning_of_quarter; end
  def at_beginning_of_week(start_day = T.unsafe(nil)); end
  def at_beginning_of_year; end
  def at_end_of_month; end
  def at_end_of_quarter; end
  def at_end_of_week(start_day = T.unsafe(nil)); end
  def at_end_of_year; end
  def beginning_of_month; end
  def beginning_of_quarter; end
  def beginning_of_week(start_day = T.unsafe(nil)); end
  def beginning_of_year; end
  def days_ago(days); end
  def days_since(days); end
  def days_to_week_start(start_day = T.unsafe(nil)); end
  def end_of_month; end
  def end_of_quarter; end
  def end_of_week(start_day = T.unsafe(nil)); end
  def end_of_year; end
  def future?; end
  def last_month; end
  def last_quarter; end
  def last_week(start_day = T.unsafe(nil), same_time: T.unsafe(nil)); end
  def last_weekday; end
  def last_year; end
  def monday; end
  def months_ago(months); end
  def months_since(months); end
  def next_day; end
  def next_month; end
  def next_quarter; end
  def next_week(given_day_in_next_week = T.unsafe(nil), same_time: T.unsafe(nil)); end
  def next_weekday; end
  def next_year; end
  def on_weekday?; end
  def on_weekend?; end
  def past?; end
  def prev_day; end
  def prev_month; end
  def prev_quarter; end
  def prev_week(start_day = T.unsafe(nil), same_time: T.unsafe(nil)); end
  def prev_weekday; end
  def prev_year; end
  def sunday; end
  def today?; end
  def tomorrow; end
  def weeks_ago(weeks); end
  def weeks_since(weeks); end
  def years_ago(years); end
  def years_since(years); end
  def yesterday; end

  private

  def copy_time_to(other); end
  def days_span(day); end
  def first_hour(date_or_time); end
  def last_hour(date_or_time); end
end

DateAndTime::Calculations::DAYS_INTO_WEEK = T.let(T.unsafe(nil), Hash)
DateAndTime::Calculations::WEEKEND_DAYS = T.let(T.unsafe(nil), Array)

module DateAndTime::Compatibility
  def preserve_timezone; end

  class << self
    def preserve_timezone; end
    def preserve_timezone=(obj); end
  end
end

module DateAndTime::Zones
  def in_time_zone(zone = T.unsafe(nil)); end

  private

  def time_with_zone(time, zone); end
end

class DateTime < ::Date
  include ::DateAndTime::Compatibility

  def <=>(other); end
  def acts_like_date?; end
  def acts_like_time?; end
  def advance(options); end
  def ago(seconds); end
  def as_json(options = T.unsafe(nil)); end
  def at_beginning_of_day; end
  def at_beginning_of_hour; end
  def at_beginning_of_minute; end
  def at_end_of_day; end
  def at_end_of_hour; end
  def at_end_of_minute; end
  def at_midday; end
  def at_middle_of_day; end
  def at_midnight; end
  def at_noon; end
  def beginning_of_day; end
  def beginning_of_hour; end
  def beginning_of_minute; end
  def blank?; end
  def change(options); end
  def default_inspect; end
  def end_of_day; end
  def end_of_hour; end
  def end_of_minute; end
  def formatted_offset(colon = T.unsafe(nil), alternate_utc_string = T.unsafe(nil)); end
  def getgm; end
  def getlocal(utc_offset = T.unsafe(nil)); end
  def getutc; end
  def gmtime; end
  def in(seconds); end
  def inspect; end
  def localtime(utc_offset = T.unsafe(nil)); end
  def midday; end
  def middle_of_day; end
  def midnight; end
  def noon; end
  def nsec; end
  def readable_inspect; end
  def seconds_since_midnight; end
  def seconds_until_end_of_day; end
  def since(seconds); end
  def subsec; end
  def to_f; end
  def to_formatted_s(format = T.unsafe(nil)); end
  def to_i; end
  def to_s(format = T.unsafe(nil)); end
  def to_time; end
  def usec; end
  def utc; end
  def utc?; end
  def utc_offset; end

  private

  def offset_in_seconds; end
  def seconds_since_unix_epoch; end

  class << self
    def civil_from_format(utc_or_local, year, month = T.unsafe(nil), day = T.unsafe(nil), hour = T.unsafe(nil), min = T.unsafe(nil), sec = T.unsafe(nil)); end
    def current; end
  end
end

module Digest::UUID
  class << self
    def uuid_from_hash(hash_class, uuid_namespace, name); end
    def uuid_v3(uuid_namespace, name); end
    def uuid_v4; end
    def uuid_v5(uuid_namespace, name); end
  end
end

Digest::UUID::DNS_NAMESPACE = T.let(T.unsafe(nil), String)
Digest::UUID::OID_NAMESPACE = T.let(T.unsafe(nil), String)
Digest::UUID::URL_NAMESPACE = T.let(T.unsafe(nil), String)
Digest::UUID::X500_NAMESPACE = T.let(T.unsafe(nil), String)

module ERB::Util
  private

  def h(s); end
  def html_escape(s); end
  def html_escape_once(s); end
  def json_escape(s); end
  def unwrapped_html_escape(s); end

  class << self
    def h(s); end
    def html_escape(s); end
    def html_escape_once(s); end
    def json_escape(s); end
    def unwrapped_html_escape(s); end
  end
end

ERB::Util::HTML_ESCAPE = T.let(T.unsafe(nil), Hash)
ERB::Util::HTML_ESCAPE_ONCE_REGEXP = T.let(T.unsafe(nil), Regexp)
ERB::Util::JSON_ESCAPE = T.let(T.unsafe(nil), Hash)
ERB::Util::JSON_ESCAPE_REGEXP = T.let(T.unsafe(nil), Regexp)

module Enumerable
  def as_json(options = T.unsafe(nil)); end
  def exclude?(object); end
  def index_by; end
  def many?; end
  def pluck(*keys); end
  def sum(identity = T.unsafe(nil), &block); end
  def without(*elements); end
end

class Exception
  include ::ActiveSupport::Dependencies::Blamable

  def as_json(options = T.unsafe(nil)); end
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass

  def as_json(options = T.unsafe(nil)); end
  def blank?; end
  def to_param; end
end

class Float < ::Numeric
  include ::JSON::Ext::Generator::GeneratorMethods::Float

  def as_json(options = T.unsafe(nil)); end
end

class Hash
  include ::Enumerable
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  include ::Mocha::Inspect::HashMethods

  def as_json(options = T.unsafe(nil)); end
  def assert_valid_keys(*valid_keys); end
  def deep_dup; end
  def deep_merge(other_hash, &block); end
  def deep_merge!(other_hash, &block); end
  def deep_stringify_keys; end
  def deep_stringify_keys!; end
  def deep_symbolize_keys; end
  def deep_symbolize_keys!; end
  def deep_transform_keys(&block); end
  def deep_transform_keys!(&block); end
  def except(*keys); end
  def except!(*keys); end
  def extract!(*keys); end
  def extractable_options?; end
  def nested_under_indifferent_access; end
  def reverse_merge(other_hash); end
  def reverse_merge!(other_hash); end
  def reverse_update(other_hash); end
  def slice(*keys); end
  def slice!(*keys); end
  def stringify_keys; end
  def stringify_keys!; end
  def symbolize_keys; end
  def symbolize_keys!; end
  def to_options; end
  def to_options!; end
  def to_param(namespace = T.unsafe(nil)); end
  def to_query(namespace = T.unsafe(nil)); end
  def to_xml(options = T.unsafe(nil)); end
  def with_indifferent_access; end

  private

  def _deep_transform_keys_in_object(object, &block); end
  def _deep_transform_keys_in_object!(object, &block); end

  class << self
    def from_trusted_xml(xml); end
    def from_xml(xml, disallowed_types = T.unsafe(nil)); end
  end
end

HashWithIndifferentAccess = ActiveSupport::HashWithIndifferentAccess

module I18n
  extend ::I18n::Base

  class << self
    def interpolate(string, values); end
    def interpolate_hash(string, values); end
    def new_double_nested_cache; end
  end
end

I18n::DEFAULT_INTERPOLATION_PATTERNS = T.let(T.unsafe(nil), Array)
I18n::EMPTY_HASH = T.let(T.unsafe(nil), Hash)
I18n::INTERPOLATION_PATTERN = T.let(T.unsafe(nil), Regexp)
I18n::RESERVED_KEYS = T.let(T.unsafe(nil), Array)
I18n::RESERVED_KEYS_PATTERN = T.let(T.unsafe(nil), Regexp)

class I18n::Railtie < ::Rails::Railtie
  class << self
    def include_fallbacks_module; end
    def init_fallbacks(fallbacks); end
    def initialize_i18n(app); end
    def validate_fallbacks(fallbacks); end
    def watched_dirs_with_extensions(paths); end
  end
end

I18n::VERSION = T.let(T.unsafe(nil), String)

class Integer < ::Numeric
  include ::JSON::Ext::Generator::GeneratorMethods::Integer

  def month; end
  def months; end
  def year; end
  def years; end
end

Integer::GMP_VERSION = T.let(T.unsafe(nil), String)

module Kernel
  def class_eval(*args, &block); end

  private

  def enable_warnings; end
  def silence_warnings; end
  def suppress(*exception_classes); end
  def with_warnings(flag); end

  class << self
    def enable_warnings; end
    def silence_warnings; end
    def suppress(*exception_classes); end
    def with_warnings(flag); end
  end
end

class LoadError < ::ScriptError
  def is_missing?(location); end
end

LoadError::REGEXPS = T.let(T.unsafe(nil), Array)

module LoggerSilence
  extend ::ActiveSupport::Concern

  def silence(temporary_level = T.unsafe(nil)); end
end

class Method
  include ::MethodSource::SourceLocation::MethodExtensions
  include ::MethodSource::MethodExtensions

  def duplicable?; end
end

MissingSourceFile = T.let(T.unsafe(nil), ActiveSupport::Deprecation::DeprecatedConstantProxy)

class Module
  include ::Module::Concerning
  include ::ActiveSupport::Dependencies::ModuleConstMissing

  def alias_attribute(new_name, old_name); end
  def alias_method_chain(target, feature); end
  def anonymous?; end
  def attr_internal(*attrs); end
  def attr_internal_accessor(*attrs); end
  def attr_internal_reader(*attrs); end
  def attr_internal_writer(*attrs); end
  def cattr_accessor(*syms, &blk); end
  def cattr_reader(*syms); end
  def cattr_writer(*syms); end
  def delegate(*methods, to: T.unsafe(nil), prefix: T.unsafe(nil), allow_nil: T.unsafe(nil)); end
  def deprecate(*method_names); end
  def local_constants; end
  def mattr_accessor(*syms, &blk); end
  def mattr_reader(*syms); end
  def mattr_writer(*syms); end
  def method_visibility(method); end
  def parent; end
  def parent_name; end
  def parents; end
  def qualified_const_defined?(path, search_parents = T.unsafe(nil)); end
  def qualified_const_get(path); end
  def qualified_const_set(path, value); end
  def reachable?; end
  def redefine_method(method, &block); end
  def remove_possible_method(method); end
  def remove_possible_singleton_method(method); end
  def thread_cattr_accessor(*syms, &blk); end
  def thread_cattr_reader(*syms); end
  def thread_cattr_writer(*syms); end
  def thread_mattr_accessor(*syms, &blk); end
  def thread_mattr_reader(*syms); end
  def thread_mattr_writer(*syms); end

  private

  def attr_internal_define(attr_name, type); end
  def attr_internal_ivar_name(attr); end

  class << self
    def attr_internal_naming_format; end
    def attr_internal_naming_format=(_arg0); end
  end
end

module Module::Concerning
  def concern(topic, &module_definition); end
  def concerning(topic, &block); end
end

Module::DELEGATION_RESERVED_KEYWORDS = T.let(T.unsafe(nil), Array)
Module::DELEGATION_RESERVED_METHOD_NAMES = T.let(T.unsafe(nil), Set)
class Module::DelegationError < ::NoMethodError; end
Module::RUBY_RESERVED_KEYWORDS = T.let(T.unsafe(nil), Array)

class NameError < ::StandardError
  include ::DidYouMean::Correctable

  def missing_name; end
  def missing_name?(name); end
end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass

  def as_json(options = T.unsafe(nil)); end
  def blank?; end
  def to_param; end
  def try(*args); end
  def try!(*args); end
end

class Numeric
  include ::Comparable

  def as_json(options = T.unsafe(nil)); end
  def blank?; end
  def byte; end
  def bytes; end
  def day; end
  def days; end
  def exabyte; end
  def exabytes; end
  def fortnight; end
  def fortnights; end
  def gigabyte; end
  def gigabytes; end
  def hour; end
  def hours; end
  def html_safe?; end
  def in_milliseconds; end
  def kilobyte; end
  def kilobytes; end
  def megabyte; end
  def megabytes; end
  def minute; end
  def minutes; end
  def petabyte; end
  def petabytes; end
  def second; end
  def seconds; end
  def terabyte; end
  def terabytes; end
  def week; end
  def weeks; end
end

Numeric::EXABYTE = T.let(T.unsafe(nil), Integer)
Numeric::GIGABYTE = T.let(T.unsafe(nil), Integer)
Numeric::KILOBYTE = T.let(T.unsafe(nil), Integer)
Numeric::MEGABYTE = T.let(T.unsafe(nil), Integer)
Numeric::PETABYTE = T.let(T.unsafe(nil), Integer)
Numeric::TERABYTE = T.let(T.unsafe(nil), Integer)

class Object < ::BasicObject
  include ::PP::ObjectMixin
  include ::Kernel
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::ActiveSupport::Tryable
  include ::Minitest::Expectations
  include ::Mocha::ParameterMatchers::InstanceMethods
  include ::Mocha::Inspect::ObjectMethods
  include ::Mocha::ObjectMethods
  include ::ActiveSupport::Dependencies::Loadable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder

  def acts_like?(duck); end
  def as_json(options = T.unsafe(nil)); end
  def blank?; end
  def deep_dup; end
  def duplicable?; end
  def html_safe?; end
  def in?(another_object); end
  def instance_values; end
  def instance_variable_names; end
  def presence; end
  def presence_in(another_object); end
  def present?; end
  def to_param; end
  def to_query(key); end
  def with_options(options, &block); end
end

class Process::Status
  def as_json(options = T.unsafe(nil)); end
end

class Range
  include ::ActiveSupport::RangeWithFormat
  include ::ActiveSupport::IncludeWithRange
  include ::ActiveSupport::EachTimeWithZone
  include ::Enumerable

  def as_json(options = T.unsafe(nil)); end
  def overlaps?(other); end
  def sum(identity = T.unsafe(nil)); end
end

class Regexp
  def as_json(options = T.unsafe(nil)); end
  def multiline?; end
end

class String
  include ::Comparable
  include ::JSON::Ext::Generator::GeneratorMethods::String
  include ::Colorize::InstanceMethods
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend
  extend ::Colorize::ClassMethods

  def acts_like_string?; end
  def as_json(options = T.unsafe(nil)); end
  def at(position); end
  def blank?; end
  def camelcase(first_letter = T.unsafe(nil)); end
  def camelize(first_letter = T.unsafe(nil)); end
  def classify; end
  def constantize; end
  def dasherize; end
  def deconstantize; end
  def demodulize; end
  def first(limit = T.unsafe(nil)); end
  def foreign_key(separate_class_name_and_id_with_underscore = T.unsafe(nil)); end
  def from(position); end
  def html_safe; end
  def humanize(options = T.unsafe(nil)); end
  def in_time_zone(zone = T.unsafe(nil)); end
  def is_utf8?; end
  def last(limit = T.unsafe(nil)); end
  def mb_chars; end
  def parameterize(sep = T.unsafe(nil), separator: T.unsafe(nil), preserve_case: T.unsafe(nil)); end
  def pluralize(count = T.unsafe(nil), locale = T.unsafe(nil)); end
  def remove(*patterns); end
  def remove!(*patterns); end
  def safe_constantize; end
  def singularize(locale = T.unsafe(nil)); end
  def squish; end
  def squish!; end
  def strip_heredoc; end
  def tableize; end
  def titlecase; end
  def titleize; end
  def to(position); end
  def to_date; end
  def to_datetime; end
  def to_time(form = T.unsafe(nil)); end
  def truncate(truncate_at, options = T.unsafe(nil)); end
  def truncate_words(words_count, options = T.unsafe(nil)); end

  sig { returns(String) }
  def underscore; end

  def upcase_first; end
end

String::BLANK_RE = T.let(T.unsafe(nil), Regexp)

class Struct
  include ::Enumerable

  def as_json(options = T.unsafe(nil)); end
end

Struct::Group = Etc::Group
Struct::HTMLElementDescription = Struct
Struct::Passwd = Etc::Passwd
Struct::Tms = Process::Tms

class Symbol
  include ::Comparable

  def as_json(options = T.unsafe(nil)); end
end

class Time
  include ::Comparable
  include ::DateAndTime::Zones
  include ::DateAndTime::Calculations
  include ::DateAndTime::Compatibility
  include ::Mocha::Inspect::TimeMethods

  def +(other); end
  def -(other); end
  def <=>(other); end
  def acts_like_time?; end
  def advance(options); end
  def ago(seconds); end
  def all_day; end
  def as_json(options = T.unsafe(nil)); end
  def at_beginning_of_day; end
  def at_beginning_of_hour; end
  def at_beginning_of_minute; end
  def at_end_of_day; end
  def at_end_of_hour; end
  def at_end_of_minute; end
  def at_midday; end
  def at_middle_of_day; end
  def at_midnight; end
  def at_noon; end
  def beginning_of_day; end
  def beginning_of_hour; end
  def beginning_of_minute; end
  def blank?; end
  def change(options); end
  def compare_with_coercion(other); end
  def end_of_day; end
  def end_of_hour; end
  def end_of_minute; end
  def eql?(other); end
  def eql_with_coercion(other); end
  def formatted_offset(colon = T.unsafe(nil), alternate_utc_string = T.unsafe(nil)); end
  def in(seconds); end
  def midday; end
  def middle_of_day; end
  def midnight; end
  def minus_with_coercion(other); end
  def minus_with_duration(other); end
  def minus_without_coercion(other); end
  def noon; end
  def plus_with_duration(other); end
  def sec_fraction; end
  def seconds_since_midnight; end
  def seconds_until_end_of_day; end
  def since(seconds); end
  def to_formatted_s(format = T.unsafe(nil)); end
  def to_s(format = T.unsafe(nil)); end
  def to_time; end

  class << self
    def ===(other); end
    def at(*args); end
    def at_with_coercion(*args); end
    def current; end
    def days_in_month(month, year = T.unsafe(nil)); end
    def days_in_year(year = T.unsafe(nil)); end
    def find_zone(time_zone); end
    def find_zone!(time_zone); end
    def use_zone(time_zone); end
    def zone; end
    def zone=(time_zone); end
    def zone_default; end
    def zone_default=(_arg0); end
  end
end

Time::COMMON_YEAR_DAYS_IN_MONTH = T.let(T.unsafe(nil), Array)
Time::DATE_FORMATS = T.let(T.unsafe(nil), Hash)

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass

  def as_json(options = T.unsafe(nil)); end
  def blank?; end
  def to_param; end
end
